---
title: "Programming in R"
subtitle: "[hyperlink to presentation]()"
author: "fill presenter names here"
format:
  revealjs:
    theme: "theme.scss"
    transition: fade
    background-transition: fade
    highlight-style: ayu-mirage
    fontsize: 2em
code-link: true
execute:
  echo: true
  freeze: auto

---

# Course Overview

1.  [Introduction](#intro)
2.  [Objects in R](#objects)
3.  [Graphics](#graphics)
4.  [Data Analysis (dplyr)](#dataanalysis)
5.  [Programming: Flow Control](#flowcontrol)
6.  [Regressions](#regression)
7.  [Monte Carlo Simulations](#mc)
8.  [Numerical Optimization](#optim)
9.  [Bootstrap](#bootstrap)
10. [Efficiency](#efficiency)

# Preliminary Remarks

## Infrastructure

You'll need a

-   Personal computer with a current installation of R and RStudio
    -   Go to [CRAN](https://cran.r-project.org/) to download the appropriate version for your operating system.
    -   Follow the installation instructions provided on the website.
    -   Install RStudio from [RStudio](https://posit.co/download/rstudio-desktop/) for a user-friendly interface.
-   Folder structure consistent with the course:
    -   `code/`
    -   `RData/`

## Literature/Links

-   Kleiber, C. & Zeileis, A. (2008), [Applied Econometrics with R](https://www.springer.com/de/book/9780387773162), Springer.

-   Braun, J. & Murdoch, D. (2021), [A first course in statistical programming with R](https://www.murdoch-sutherland.com/StatProg3/index.html)

-   Wickham, H. (2019) [Advanced R](https://adv-r.hadley.nz/)

-   Wickham, H. & Grolemund, G. (2017), [R for Data Science](https://r4ds.had.co.nz/)

-   Verzani, J. (2014), [Using R for Introductory Statistics](https://www.crcpress.com/Using-R-for-Introductory-Statistics/Verzani/p/book/9781466590734)

-   Matloff, N. (2011), [The Art of R Programming](https://nostarch.com/artofr.htm)

-   Wickham, H. (2023) [R Packages](https://r-pkgs.org)

-   Course website: [tbd](tbd)

-   [R project](https://www.r-project.org/)

-   Any further references?

## Learning Goals:

-   Introductory knowledge in R and RStudio
-   Sufficient knowledge to help yourself
-   Loading, describing and manipulating data
-   Descriptive statistics
-   Visualization
-   Model estimation
-   Baseline programming knowledge

## Exam

-   Provide information about the exam here

# 1. Introduction

------------------------------------------------------------------------

## General Information

**R** is...

-   a free implementation of the **S** programming language with the goals:
    -   Interactive data analysis
    -   Making it easy for users to become programmers
    -   Creating graphics for data analysis
    -   Easy reusability of existing functions
-   a *interpreted* language (interpreted by the R interpreter at runtime)
-   a *functional* language (functions are first-class objects)
-   an *object-oriented* language (classes and methods)
-   a *vectorized* language (objects are internally represented as vectors)

## Advantages of R
-   Free (open-source, GPL2/3) software; all code can be inspected and verified
-   Very close to (statistical) research
-   Easily extendable through packages
-   Runs on almost all platforms
-   Widely applied
-   Similar to other OOP languages in statistics (Python, Matlab, Julia)

## Disadvantages of R

-   No graphical user interface (but RStudio / Emacs + ESS / VS Code)
-   No interactive graphics (but Shiny)
-   Interpreted language, sometimes slower compared to compiled languages.
-   But: Compiled code (C/C++, Fortran) can be integrated to overcome this. Either via `Rcpp` (fast, user-friendly) or by calling C / Fortran routines directly (faster, less user-friendly)

## First Steps

-   Input *expressions* into the R console (the interpreter), execute with *Return*
-   Use arrow keys <em>(↑, ↓)</em> to recall previously entered *expressions*

```{r, list1, echo=TRUE,eval=TRUE, prompt=TRUE,results = 'hold'}
sin(2*pi)
2 - 1
0/0         # -> NaN (not defined)
Inf-Inf     # -> NaN (not defined)
2 + 3*4     # Operator precedence
2 + 
1       # Execution only when expression is complete
```

## Graphics: {#graphics}

```{r, list2, echo=TRUE, fig.align='center', fig.width=7, fig.height=6}
set.seed(123)
x <- runif(100)
y <- x + rnorm(100, sd = 0.1)
plot(x,y)
```

------------------------------------------------------------------------

While many simple calculations can be done using the command line, as soon as things get more complicated, *scripts* should be used.

A script is a text file (usually with a '.R' file extension) that contains R code. For example:

```{r, list3, echo=TRUE, eval = FALSE}
## Change working directory
setwd("C:/Users/Max/R-Code")

## Load data
myData <- read.table("all_important_data.csv",
                     sep = ";", header = TRUE)

## Summary
summary(myData)
```

## Editors

Text files are edited using text editors. There are several editors that make working with R easier:

-   R-Studio (used in this course)
    -   Closest to a GUI
    -   Plots, overview of objects and packages in one window
    -   Extra-click functions like loading data
    -   Highly recommended for beginners
-   Notepad++ in connection with npptor (Notepad++ to R)
    -   Flexible editor for various programming languages, text files, etc. (one editor for multiple languages?)
    -   Extremely functional as an editor: add-ons, macros, hotkeys, etc.
    -   Comfortable indentation, highlighting, commenting and uncommenting

------------------------------------------------------------------------

-   (X)Emacs with ESS / VS Code with R extension
    -   Extremely versatile and powerful editor, though it requires some learning
    -   Highly customizable
    -   Works on all platforms
    -   Suitable for various applications (LaTeX, email, git, etc.)

## RStudio

-   Structure: 4 windows

    -   Top left: Code editor, data.frame view (**Ctrl + 1**)
    -   Bottom left: R console (**Ctrl + 2**)
    -   Top right: Display of objects in the global environment (**Ctrl + 8**), history (**Ctrl + 4**)
    -   Bottom right: Help (**Ctrl + 3**), plots (**Ctrl + 6**), packages (**Ctrl + 7**), etc.

-   Individual windows can now also be detached from the main window

-   To execute code from the editor:

    -   Place the cursor in the respective line
    -   Press **Ctrl + Enter** → Cursor jumps to the next line

## Getting Help on a Topic

To get help on a *known* function, you can either search for the function in the RStudio help tab or enter the following in the R console:

```{r list4, eval = FALSE, echo = TRUE}
?getwd
```

<br> <img src="figures/getwd-help.png" style="width: 60%" align="center"/> 

## Getting Help on a Topic

If you are looking for an *unknown* function (e.g., a function that performs a t-test), the best approach is to use Google, e.g.:

<img src="figures/google-search.png" style="align:center;width: 100%"/>

As a more recent alternative, consult a LLM but make sure to check the proposed solution for errors

## Getting Help on a Topic
-   Each package has its own documentation (includes help files), often with vignettes (more detailed explanations)
-   Stack Overflow
-   Mailing lists such as R-help

## R as a Calculator

```{r list5, eval = FALSE, echo = TRUE}
1 + 2          # -> 3
1 + (2 * 4)    # -> 9
a <- 3
b <- 3 * a     # -> 9
sqrt(b)        # -> 3
```

-   Basic operators: +, -, \*, /, \^
-   Extreme values: min(), max(), abs()
-   Square roots: sqrt()
-   Rounding: round(), floor(), ceil()
-   Trigonometric functions: sin(), cos(), tan(), asin(), acos(), atan()
-   Logarithms: log(), log2(), log10(), exp()
-   Sum, product: sum(), prod()

## Functions

Whenever something *happens*, functions are called. All operators, control flows, etc., are functions in R.

-   A function is called by specifying the function name followed by one or more comma-separated arguments in parentheses: `function_name(argument1 = value1, argument2 = value2,...)`

-   Argument names do not always need to be specified: `function_name(value1, value2,...)`

-   Attention: Order matters!

-   There are also default arguments, which do not always need to be specified. More on this later.

## Assignment

The symbol `<-` is the assignment operator, storing the value of the expression on the right into the variable on the left:

```{r list6, eval = FALSE}
a <- (3 * 4)
(3 * 4) -> a    # Also possible but not recommended
a = (3 * 4)     # Also frequently used but not equivalent to '<-'
a<-(3*4)        # Poor readability
```

-   For readability, always include spaces around the assignment operator.
-   Variable names must start with a letter but may contain numbers, periods, and underscores.
-   It is recommended to use a consistent naming convention for objects — more on this later.

## Logical Operators

-   Comparison: ==, !=, \>, \<, \>=, \<=
-   Logical expressions: TRUE, T, FALSE, F, NA
-   Operators: ! (Negotiation), xor() (exclusive or), & && (and), \| \|\| (or), all(), any()

Examples:

```{r list7, eval = FALSE}
TRUE & FALSE   # FALSE
TRUE & TRUE    # TRUE
TRUE | FALSE   # TRUE
!TRUE | FALSE  # FALSE
FALSE && TRUE  # Second TRUE is not evaluated
TRUE && TRUE   # Second TRUE is evaluated
TRUE || FALSE  # Second FALSE is not evaluated
```

------------------------------------------------------------------------

More Examples:

```{r list8, eval = FALSE}
c(TRUE, FALSE) & c(TRUE, TRUE)  # [1] TRUE FALSE   -> Vectorized
c(TRUE, FALSE) && c(TRUE, TRUE) # [1] TRUE         -> Not vectorized
```

Quantifiers:

```{r list9, eval = FALSE}
a <- c(TRUE, FALSE, TRUE)
b <- c(TRUE, TRUE, TRUE)
any(a)         # [1] TRUE
all(a)         # [1] FALSE
all(b)         # [1] TRUE
```

------------------------------------------------------------------------

Missing Values:

Testing for `NA` is only possible with `is.na()`. `x == NA` always returns `NA`!

Examples:

```{r list10, eval = FALSE}
a <- c(TRUE, NA, TRUE)
a == NA           # [1] NA NA NA
is.na(a)          # [1] FALSE TRUE FALSE
```

------------------------------------------------------------------------

## Useful Functions:

-   `ls()` displays existing objects in the global environment
-   `str()` shows the structure of an object
-   `rm()` removes an object from the global workspace
-   `getwd()` displays the current working directory
-   `setwd()` changes the working directory
    -   On Windows, the path separator is either `/` or `\\`
    -   On Linux/Mac, always `/`
-   `save()` saves objects as an `.RData` file
-   `load()` loads objects into the global environment
-   `list.files()` shows files in the specified directory
-   `source()` runs an R script

## Extending R with Packages

There are many packages available on [CRAN](https://cran.r-project.org/) for various applications. These allow for expanding the relatively small core system of R. While R comes with some standard packages, many need to be installed separately.

```{r list11, eval = FALSE}
install.packages("AER")  # Install a previously unavailable package
library(AER)             # Load the package (makes objects 
                         # in the package visible in the
                         # global namespace)
data(CASchools)          # Example dataset "CASchools"
?ivreg                   # Help for function ivreg
```

-   `search()` shows the search path, i.e., which packages are already loaded:

```{r list12, eval = TRUE}
search()
```

## Task 1.1

Create a file `test.R` in your `codes` folder. This file should contain a script that creates the object `x` assigned to `5` and the object `y` assigned to `6`. Before sourcing this `test.R` file using the `source` function, clear your entire workspace. Then, inspect the workspace, compute the product of the two numbers, delete the object `x`, and save the remaining workspace in `.RData` format in the "RData" folder.

**Note:** In general, it is wise to avoid frequently changing the working directory. Instead, simply use the `source` function on the explicit code folder.

## Task 1.2

Test R as a calculator: 1. Compute the value of the sine function at `0`. 2. Define `x` as `2` and compute its double third power.

## Task 1.3

Find an R package that provides functions to test linear hypotheses in multiple regression models. Install the package and check the help documentation for one of its functions.

## Task 1.4

1.  Compute the following:
    -   The cube root of 27.
    -   The exponential of 3.
    -   The tangent of π/6.
2.  Use logical operators to evaluate:
    -   10 \<= 15 & 5 \> 3
    -   !(7 != 7)
    -   c(TRUE, FALSE, TRUE) & c(FALSE, TRUE, TRUE)

## Task 1.5

1.  Assign the value 42 to a variable named answer. Then, multiply it by 2 and store the result in a new variable double_answer.
2.  Create a variable name with the value "R Programming". Use the paste() function to combine it with "is fun!".
3.  Swap the values of two variables a = 5 and b = 10 without using a temporary variable.

## Task 1.6

1.  Use the help() function to find information about the lm() function.
2.  Now, use google to find out how to apply the lm() function.
3.  Use a LLM of your choice to generate a summary of the lm() function.

# 2. Objects in R

------------------------------------------------------------------------

## Objects in R

-   Everything that exists in R (objects) is either data (a structure) or a function.
-   Objects each have a class (object orientation).

## First Important Object: Functions

A function is a programming construct that executes a procedure on provided objects and returns a result.

```{r list13, eval = TRUE, results='hold'}
log(2.3)
sin(2)
class(log)
class(2.3)
```

## Functions

There are functions with and without side effects:

-   Functions **without** side effects take objects as input, perform an operation, and return the result. Example: `log()`
-   Functions **with** side effects modify objects in the global workspace. Example: `setwd()`, `'<-'()` (assignment is also a function!)

$\Rightarrow$ When developing functions, side effects should be avoided unless explicitly desired.

## Defining a Function

A function is defined as follows:

```{r list14, eval = FALSE}
## Simple function
product1 <- function(x1, x2) x1 * x2

## With preset arguments
product2 <- function(x1 = 1, x2 = 2) x1 * x2

## Curly braces often used for function bodies
product3 <- function(x1 = 1, x2 = 2){
  x1 * x2
}
```

-   In the example above, curly braces are not necessary. However, they should be used when a function performs multiple operations.

## Calling a Function

```{r list15, eval = FALSE}
product1                      # Display function definition
product1()                    # Calling function without arguments produces an error
product1(x1=2, x2=5)
product1(x1=2, x2=5, y=5)     # Function expects exactly 2 arguments, providing 3 will cause an error
```

**What happens when the function is called?**

`product1(x1 = 1,x2 = 2)`

At runtime, a new environment is created, containing two variables: `x1` with value `1` and `x2` with value `2`. These are used to compute the product, which is then returned.

------------------------------------------------------------------------

Not all functions require arguments, e.g., `getwd()`:

```{r list16, eval = FALSE}
f2 <- function() x1 * x2
x1 <- 2
x2 <- 3
f2              # Display function definition
f2()            # Call function
f2(x1=2)        # Produces an error, f2 does not accept arguments
f2(2)
```

Since `f2` has no arguments, `x1` and `x2` are searched in the next higher environment.

```{r list17, eval=FALSE}
rm(x1,x2)
f2()            # Error
```

## More complex Function Example

```{r list18, eval = FALSE}
f4 <- function(x1,x2) {
    z <- x1 + x2
    abc <- x1/z
    return(abc)     # return exits the function
}
f4(1,2)             # -> 0.3333333
```

------------------------------------------------------------------------

## Special Argument: The "Three Dots" Argument (`...`)

A special argument in R is the "three dots" argument (`...`). This allows arguments to be passed flexibly:

```{r list19, eval = FALSE}
f5 <- function(e, ...) {
    log(e, ...)^2
}
```

All arguments that `f5` does not explicitly use are passed to `log()`:

```{r list20, eval=FALSE}
f5(5)
log(5, base=10)^2             # log() also has an argument "base"
f5(5, base = 10)              # Passed to log()
f5(5, base = 10, arg3 = "a")  # arg3 is not recognized by log()
```

## Functions That Call Methods

Some functions, such as `print()`, `summary()`, and `plot()`, call methods. These perform different operations depending on the class of the passed object.

```{r list21, eval=FALSE}
plot(cos, -1, 1)    # 'plot' applied to function 'cos'
x <- 1:5
y <- 6:10
plot(x, y)          # 'plot' applied to two vectors 'x' and 'y'
```

R has two (recently three) class systems: S3, S4, and Reference Classes (the latter being closest to object-oriented programming).

## Summary: Functions

All objects that are not data are functions.

What you should now know:

-   Function name, function body, function definition

For the source code of a function (R is NOT a black box!), Uwe Ligges' [article in R News (p. 43)](https://cran.r-project.org/doc/Rnews/Rnews_2006-4.pdf) is a great reference.

"When looking at R source code, sometimes calls to one of the following functions show up: `.C()`, `.Call()`, `.Fortran()`, `.External()`, or `.Internal()` and `.Primitive()`. These functions call entry points in compiled code such as shared objects, static libraries, or dynamic link libraries. Therefore, it is necessary to look into the sources of the compiled code if complete understanding of the code is required. ... The first step is to look up the entry point in file `$R HOME/src/main/names.c`, if the calling R function is either `.Primitive()` or `.Internal()`."

## Task 2.1

1.  Create a function named `getSquaredSum` that takes two numbers as input, calculates their squared sum, and returns it. Test this function in two ways. Then, set the second function argument to default to `0`.

2.  Create a function in which another function is defined and then called within the function body. Now define the "inner function" outside of the "outer function." Which approach do you prefer? Check if everything works and produces the same results!

## Atomic Data Types

All complex data types (vectors, matrices, lists, etc.) in R are built from atomic data types:

-   `NULL`: the empty set
-   `logical`: logical values
-   `integer`: whole numbers
-   `numeric`: real numbers
-   `complex`: complex numbers
-   `character`: letters and strings
-   For more, see `?typeof`

```{r list22, eval = FALSE}
typeof(2.3)    # numeric
typeof(TRUE)   # logical
typeof("abc")  # character
typeof(log)    # special
```

## Atomic Data Type Functions

For each atomic data type, there is a function to check if an object belongs to that type, as well as a function to convert (if possible) into the respective type:

```{r list23, eval = FALSE}
is.numeric(1)       # TRUE
as.numeric("2.3")   # 2.3
as.character(2.3)   # "2.3"
is.null(NULL)       # TRUE
```

## Vectors

Vectors are the fundamental structure in R and consist of multiple elements of an atomic data type. The function `c()` is used to create vectors:

```{r list24, eval = FALSE}
x <- c(1, 2.3, 5, 1)
x <- c(2, 2, 2, x)      # new vector from an existing vector
y <- c("Test", "Hello")
y <- c(y, x)            # everything converts to 'character', the "lowest" data type
x <- c(x, NA)           # but: NA does not change the type!
```

------------------------------------------------------------------------

Other ways to create vectors:

-   Integer sequences: `1:5`, alternatively: `seq(1,5)`
-   Arbitrary sequences: `seq(from, to, by)`
-   Repetitions: `rep()`

```{r list25, eval = FALSE}
2:4              # -> 2,3,4
seq(2,8,2)       # -> 2,4,6,8
rep(2, 4)        # -> 2,2,2,2
x <- 1:3
rep(x, 2)        # -> 1,2,3,1,2,3
rep(x, each = 2) # -> 1,1,2,2,3,3
```

Individual elements in vectors can also be named:

```{r list25a, eval=FALSE}
x <- c(one = 2.4, two = 3, three = 4, last = 2)
```

## Vector Arithmetic

Since R is a vectorized language, all elementary arithmetic operations are vectorized:

```{r list26, eval = FALSE}
c(1,2,3) + c(1,1,1)  # -> 2,3,4
c(1,2) * c(1,4)      # -> 1,8
```

Warning: If vectors have different lengths, the shorter one is recycled to match the longer one. If the lengths do not align perfectly, a warning is issued:

```{r list27, eval = FALSE}
c(1,2,4) * 2         # 2,4,6 -> second object is converted to c(2,2,2)
c(1,2,4) * c(2,3)    # 2,6,8 -> with a warning
```

## Vector Indexing

To access individual elements in a vector, indexing can be used. For example, the fourth element of vector `x` is accessed with `x[4]`. Different indexing methods include:

-   Numeric indexing (also with a vector): `x[c(2,3,7)]` selects the 2nd, 3rd, and 7th elements of `x`.
-   Logical indexing: `x[c(TRUE, FALSE, TRUE, FALSE, FALSE)]` selects the 1st and 3rd elements of `x` (if `x` has five elements).
-   Named indexing: Named vectors can be accessed using names: `x["one"]` selects the element named "one".
-   Negative indexing: `x[-1]` selects all elements except the first.
-   Conditional indexing: `x[ x > 2 ]` selects all elements greater than 2 (if `x` is numeric).

## Useful Vector Functions

-   sort: sort()
-   revert: rev()
-   rank: rank()
-   order (index): order()
-   exact identical check: identical()
-   numerical equality: all.equal()
-   delete duplicaes: unique()
-   check for duplicates: duplicated()
-   which elements satisfy condition: which()

## Task 2.2

Write a function that calculates the sum of two vectors and returns the result as a string in the format:

"The sum is \[value\]".

Test the function with the following vectors:

```{r list28, eval = FALSE}
xy <- c(1,2,3)
yx <- c(4,5,6)
```

Hint: Check the help for the `paste()` function.

## Matrices

Matrices are created using the function `matrix(data= NA, ncol=1, nrow =1, byrow = FALSE)`. Example:

```{r list 29, eval = TRUE}
matrix(data = 1:9, ncol = 3, nrow = 3) # Columns are filled first, then rows
```

If `data` is not long enough, it is recycled:

```{r list 30, eval = TRUE}
matrix(data = 1, ncol = 3, nrow = 3) # Columns are filled first, then rows
```

## Matrices

```{r list 31, eval = TRUE}
matrix(data = c(1,2), ncol = 3, nrow = 3) # Columns are filled first, then rows
```

Filling by rows:

```{r list 32, eval = TRUE}
matrix(data = 1:9, ncol = 3, nrow = 3, byrow = TRUE)
```

## Matrix Indexing

Indexing matrices is similar to vector indexing (numeric, logical, by name, etc.), but requires both row and column indices:

```{r list 33, eval = FALSE}
x <- matrix(data = 1:9, ncol = 3, nrow = 3, byrow = TRUE)
x[1,3]    # Element in row 1, column 3
x[1,]     # Returns first row (as a vector)
x[,2]     # Returns second column (as a vector)
x[,2, drop = FALSE] # Returns second column (as a 3x1 matrix)
x[x>2]    # Elements greater than 2 (as a vector)
```

-   `cbind()` and `rbind()` allow matrices to be stacked column-wise or row-wise.
-   `dim()` returns the number of elements in each dimension.

## Useful Matrix Functions

-   Multiplication: %\*%
-   Choleski decomposition: chol()
-   Return / replace diagonal: diag()
-   Row / column names: dimnames()
-   Eigendecomposition: eigen()
-   Dimensions: dim(), nrow(), ncol()
-   QR decomposition: qr()
-   Inverse: solve()
-   Singular value decomposition: svd()
-   Transpose: t()

## Arrays

Matrices have two dimensions. A generalization to multiple dimensions is an array, created with the function `array(data, dim)`, where `dim` is a vector specifying the number of elements in each dimension:

```{r list 34, eval = FALSE}
array(1:30, dim = c(3,3,5))
```

This creates an array with dimensions $3 \times 3 \times 5$.

-   Indexing works the same way as for matrices.
-   Arithmetic operations are applied element-wise:

```{r list35, eval = TRUE}
A <- matrix(1:6, nrow = 2)
A^2
```

## Task 2.3

For the matrix `A = Mat_A`

```{r}
Mat_A <- matrix(1:9, ncol = 3)
```

and the vector `b = vec_b`

```{r}
vec_b <- 12:14
```

Compute the matrix product $A \cdot b$ and the element-wise product. Explain the differences.

## Task 2.4

Define the vector $y = (3,5,2,8,6,4,7)'$ and the matrix $X$, where the first column consists of ones and the second column contains $(4,3,7,1,3,7,5)'$.

1.  Extract the third observation from `X` and `y`.
2.  Compute $X'X$, $X'y$, $(X'X)^{-1}$, and the OLS estimator of the linear regression model. **Hint:** The formula for the OLS estimator is $\hat{\beta} = (X'X)^{-1}X'y$.
3.  Compute the standard errors of the coefficients under standard assumptions.
4.  Create a function that takes `y` and `X` and returns a matrix containing the OLS estimates and their standard errors as columns.

## Task 2.5

Add the following matrix to your R environment $$A = \begin{pmatrix}
1.0 &  0.5\\
0.5 & 1.0
\end{pmatrix}.$$ Calculate the eigendecomposition $V\cdot \Lambda\cdot V^{-1}$ of $A$, where $\Lambda$ is a diagonal matrix holding the eigenvalues, and $V$ is a matrix of eigenvectors. Check whether the above product equals $A$.

## Task 2.6

1.  When optimization involves a non-diagonal covariance matrix $Q$, one needs to ensure $Q$ is symmetric p.s.d., which limits the parameter space of the optimization problem. Write a bijective function $Q = f(\theta)$ that maps a three-dimensional parameter vector $\theta \in \mathbb{R}^3$ to the $2 \times 2$ covarinace matrix $Q$, $f: \theta \rightarrow Q$, ensuring $Q$ is symmetric p.s.d.

2.  Write the inverse function $f^{-1}: Q \rightarrow \theta$

3.  Use a LLM to solve the two tasks and check with your solution. What prompt do you use? Do you get the same results?

## Lists

Vectors, matrices, and arrays require all elements to be of the same data type. Lists, however, are more general as they allow arbitrary combinations of data types. A list is created using the `list()` function.

```{r list36, eval = FALSE}
L1 <- list(
  a = 1:3,
  A = matrix(1:9,3,3),
  w = "Hello!"        # Elements can have names AND be of any type!
)
```

Lists can also contain other lists:

```{r list37, eval = FALSE}
L2 <- list(
  a = 1:3,
  l1 = L1 # List within a list
)
```

## Lists

Lists are indexed using double square brackets (numeric, logical, by name):

```{r list38, eval = FALSE}
L1[[1]]    # 1,2,3     -> Vector
L1[1]      # list(1:3) -> Still a list (sublist of L1)
L1[["w"]]  # "Hello!"
```

Named lists can also be accessed using the `$` operator:

```{r list39, eval = FALSE}
L1$w       # "Hello!"
```

## Task 2.7

-   Create your own list with three different data types and names.
-   Use both numeric indexing and name-based indexing.
-   Apply the `str()` function to your list.
-   Create a list of lists of lists.

## Dataframes

Dataframes are lists whose elements are vectors of the same length but not necessarily of the same data type. Typically, datasets in R are stored in dataframes.

Dataframes are created using `data.frame()` and can be indexed both like matrices and like lists.

Examples:

```{r list40, eval = FALSE}
Players <- data.frame(
  FirstName = c("Joren","Ozgur","Bryan","Camil"),
  LastName =  c("Op de Beeck","Aktas","Smeets","Mmaee"),
  Position = c("Goalkeeper","Defender","Midfielder","Forward"),
  Age = c(19,28,32,20),
  Number = c(23,3,5,7),
  stringsAsFactors = FALSE      # Names should be read as "character"
                                # and not as "factor"
)
```

## Dataframes

Indexing:

```{r list41, eval = FALSE}
names(Players)       # Variable names
Players$FirstName    # Indexing like a list ($)
Players[,1]          # Numeric indexing like a matrix
Players[,"FirstName"] # Name-based indexing

Players[Players$LastName=="Smeets" , ] # Logical indexing
```

To add variables to the dataset:

```{r list42, eval = FALSE}
Players$Gender <- c("m", "m", "m", "m")
```

## Dataframes

Often, you want to select specific observations from a dataset. The `subset()` function is useful for this, along with the `%in%` operator:

```{r list43, eval = FALSE}
subset(Players, FirstName %in% c("Joren", "Bryan"))
```

Later, we will explore functions from the `dplyr` package, which provide more flexibility for selections.

Other useful functions for `data.frames`:

-   `summary()`: Outputs summary statistics for each variable
-   `head()`: Displays the first few rows
-   `tail()`: Displays the last few rows
-   `attach()`: Makes dataset variables visible in the global workspace
-   `split()`: Splits the dataset into subsets
-   `merge()`: Merges two datasets with different variables

## Task 2.8

Use the `data.frame` "Players" that was just created and perform the following actions:

1.  Rename the column "FirstName" to "prename".
2.  Access age in two different ways (compare the similarity of data.frame, matrix, and list indexing).
3.  Perform a logical indexing to select all people with number greater or equal to six.
4.  Add a new observation (row) with arbitrary data (e.g., yourself).
5.  Add a new characteristic (column) to the dataset, e.g. the birthdate or the number of yellow cards.
6.  Select all individuals younger than 30 years who are not goalkeepers.

## Additional Objects (Factor Variables, Ordered Categorical, Time Series, Date/Time Variables)

These special objects are not atomic data types, but they are useful in many applications.

## Factor Variables

Information about groups (categorical features) is often required. Examples include:

-   Gender
-   Car brand
-   Day of the week
-   Federal state

For this type of information, R provides factor variables, which are created using `factor()`:

```{r list44, eval = FALSE}
x <- rep(c(1,2), 4)
factor(x, labels=c("female", "male"))
Z <- c("Yes","Yes","No","Yes","Maybe","No","Maybe","Yes","Yes","No")
factor(Z)
```

## Why Use Factors?

-   Less memory usage
-   Usable in plots and regressions (e.g., coplots later)
-   `summary()`, `plot()` provide useful functionality:

```{r list45, eval=TRUE, fig.width = 5, fig.height=4}
x <- sample(x=1:2, size=100, replace = TRUE)
x <- factor(x, labels = c("male", "female"))
plot(x)
summary(x)
```

## Ordered Categories

Categorical data can sometimes have a meaningful order.

**Example:**

Surveys often include questions like:

*"AI is very helpful, but only if we understand what we want and express it clearly!"*

with response options:

-   `strongly agree`
-   `partially agree`
-   `neutral`
-   `somewhat disagree`
-   `strongly disagree`

In such cases, ordering is useful - also for statistical analysis.

## Ordered Categories

Ordered factor variables are created using the `ordered()` function:

```{r list46, eval = FALSE}
ord <- c("very good","medium","good","bad","good","bad","medium","very good","good")
class(ord)     # character

OF <- ordered(ord, levels=c("very bad","bad","medium","good","very good"))
class(OF)      # ordered, factor
```

## Task 2.9

Create a factor with the levels `"Flanders", "Wallonia", "Brussels"`. Also, create an ordered factor sorted in alphabetical order.

## Date and Time Information

Sometimes, timestamps and/or date information are needed. R provides dedicated data structures for this purpose:

```{r list47, eval = FALSE}
Sys.time()            # Current system time, e.g., "2019-11-08 19:03:43 CET"
class(Sys.time())     # "POSIXct" "POSIXt"
?POSIXct              # Help on DateTimeClasses
```

The `POSIXct` class is a data structure that stores a timestamp as the number of seconds since January 1, 1970, 00:00:00 UTC:

```{r list48, eval = FALSE}
x <- as.POSIXct("2019-11-24 10:12:05", tz = "UTC")  # Specify the 'timezone'
as.numeric(x)                                       # -> 1574590325
```

## Date and Time Formats

POSIX timestamps are a widely used convention for representing time in computers.

R provides multiple formatting options for `POSIXct`/`POSIXlt` through the `format()` function (see also the `strptime()` function and the article on [R-Bloggers](https://www.r-bloggers.com/date-formats-in-r/)).

Some format specifiers:

-   `%m`: Month as a decimal number (01-12)
-   `%y`: Year without century (00 - 99)
-   `%Y`: Year with century, e.g., 1987
-   `%H`: Hour as a decimal number

Example:

```{r list49, eval = FALSE}
x <- as.POSIXct("2019-11-24 10:12:05", tz = "UTC")
format(x, format = "%Y-%m: %H Uhr")     # "2019-11: 10 Uhr"
```

## Date Information

Often, only the date (without the time) is needed. For this, R provides the `Date` class.

```{r list50, eval = FALSE}
x <- as.Date("2019-11-24")  # Standard format: %Y-%m-%d
class(x)                     # "Date"
x <- as.Date("24.11.2019", format = "%d.%m.%Y") # Different format must be specified
as.numeric(x)                # 18224 (Number of days since 1/1/1970)
```

With the `Date` and `POSIXct` classes, calculations can be performed:

```{r list51, eval = FALSE}
(x <- as.Date("2019-11-24") - as.Date("2019-11-14")) # -> Time difference of 10 days
class(x)                                             # "difftime"
```

## Task 2.10

On November 3, 2020, the U.S. presidential election took place.

1.  Read this date into R.

2.  Format it in R as:

    -   "20201103"
    -   "2020-Nov"
    -   "Calendar week: 45"

## Task 2.11\*

On what day last year did the transition from daylight saving time to standard time occur?\
**Hint**: It is sufficient to show that this day had 25 hours.

## Time Series Data

There are several possible classes for time series in R, e.g., `ts` (from the `stats` package) and `zoo` (provided by the `zoo` package):

```{r list52, eval = FALSE}
uemp <- ts( data =  c( 4284691,4247561,4124836,3976555,
                      3812335,3687597,3715509,3705949,
                      3543866,3434067,3378747,3406389,
                      3659316,3617418,3507383,3413881),
           start = c(2007,1),
           frequency = 12)   # Starts in January 2007, monthly time series
class(uemp)                   # "ts"
```

`ts` objects can only represent regular time series. This can sometimes be inconvenient (e.g., trading days in the stock market). For irregular time series, `zoo` can be used:

```{r list53, eval = FALSE}
a      <- 1:10
a.Date <- seq(from = as.Date("2010-01-01"), to = as.Date("2020-01-01"), by = "years")[-3]
a.zoo  <- zoo(x = a, order.by = a.Date)
```

## Task 2.12

Generate a variable `Birthdate` of class date that holds your date of birth. Then, calculate how many days have passed since you have been born.

## Reading Data

There are various ways to read data into R, depending on the format in which the data is stored:

-   If data is available as an R image (`.RData`), objects within it can be easily loaded into the workspace using `load()`.
-   Structured text files are often used for datasets. For example, the dataset `Players` in CSV format (with `,` as a separator) looks like this:

```{c list54, eval = FALSE}
"","FirstName","LastName","Position","Age","Number"
"1","Joren","Op de Beeck","Goalkeeper",19,23
"2","Ozgur","Aktas","Defender",28,3
"3","Bryan","Smeets","Midfielder",32,5
"4","Camil","Mmaee","Forward",20,7
```

Functions to read structured text files include `read.table()`, `read.csv()`, `read.csv2()`, `read.delim()`, and `read.delim2()`, each with different default settings.

## Reading Data

-   `xls`/`xlsx` files: R previously had difficulties handling Excel files, but now the `readxl` package provides functions `read_xls()` and `read_xlsx()`.
-   Data from other statistical software (Stata, SPSS, Eviews, SAS, etc.) can be read using the `foreign` and `haven` packages.

Examples:

```{r list55, eval = FALSE}
data_pers <- read.table("players.csv",
                        header = TRUE, ## Variable names in the first row
                        sep = ";"      ## Column separator " ; "
                        )
```

## Reading Data

More examples (first, download a zip folder with sample files):

```{r list56,eval = FALSE}
## Download sample files
curl::curl_download(url ="https://drive.google.com/uc?export=download&id=1JMsHywhBeDAzNnqD0bHIAWJq0eB79wBr",
                    destfile = "example_data.zip")
## Unzip the files
res <- unzip("example_data.zip")
```

```{r list57, eval = FALSE}
install.packages("readxl", "haven") ## Install packages if not available
library(readxl)

excel_data <- read_xls("Africa.xls", skip = 7,
                       col_names = c("country","pop", "larea","pop_dens",
                                     "gdpppp", "gdppcppp","gdpgrwth"))

dax <- read.csv("dax.csv") ## Default values for sep, dec, and header already match!
schools_treat <- haven::read_dta("TreatmentSchools.dta") ## Specify namespace using "::"
```

## Task 2.13

Read in unemployment data (from 2013) in Germany (number and rate) at the district level into R. Download the corresponding [data set](https://www.dropbox.com/scl/fi/wu0epccdt4g3lqyv2hspb/alq.csv?rlkey=lbermmc9d3d8zfiz6wbjyepit&e=1&st=0351bm1j&dl=1).

Use the `read.table` function and import the dataset as `data_uemp`. After reading in the data, perform the following steps:

-   Print a summary (check if all variables are correct).
-   If the column headers were not read correctly, assign the following names: `DistrictKey`, `District`, `Abs_uemp`, `Rate_uemp`

## Task 2.13 (Continuation)

-   Calculate the total workforce and overall unemployment rate.

-   Truncating `DistrictKey` after dividing by 1000 assigns each number from 1 to 16 to a federal state. The order is:

    `"Schleswig-Holstein", "Hamburg", "Lower Saxony", "Bremen", "NRW", "Hessen", "Rhineland-Palatinate", "BW", "Bavaria", "Saarland", "Berlin", "Brandenburg", "Mecklenburg-Vorpommern", "Saxony", "Saxony-Anhalt", "Thuringia"`

    Add a new column indicating the federal state for each observation. **Hint**: The function `trunc()` may be useful.

-   Use the `order()` function to display the 30 districts with the highest unemployment rates.

-   Save the dataset as `uemp_regions.txt` and the complete `data.frame` (including federal states) as `uemp.RData`. (The latter, including federal states, will be needed later.)

## More Input/Output

-   Most data can be saved to disk just as they are read in using `write.csv()`, `write.table()`, `haven::write_dta()`, etc.

-   More fundamental methods to read/write data: `readLines()`/`writeLines()`, `scan()`/`write()`.

-   Database connections via the `odbc` package.

-   Reading from the clipboard after copying data from the *People* dataset:

    ```{r list58, eval = FALSE}
    players <- read.table(file(description = "clipboard"), sep = ";")
    ```

-   Network resources via `url()`, compressed files with `unz()`, etc.

See also `?connections()`.

# 3. Graphics

## R Base Graphics

-   This chapter covers graphical functions from the `graphics` package.
-   Other graphics packages include `ggplot2` (see [book](https://ggplot2-book.org/) by Hadley Wickham), `plotly`, `Rgnuplot`,...

To create plots with R's standard `graphics` package, there are *high-level* and *low-level* plotting functions. 

- *High-level* functions generate a new graphic (and open a *device*). 
- *Low-level* functions add elements to an existing graphic.

---

Available *devices* include: 

- `windows()`/`x11()`/`quartz()`: Screen graphics (Windows, Unix, Mac), (default). 
- `pdf()`: Adobe PDF (easily integrated into LaTeX). 
- `svg()`: Scalable Vector Graphics (commonly used on websites). 
- `png()`, `jpeg()`, `tiff()`, `bmp()`: Various bitmap formats.




---


Creating a graphic:

```{r list60, eval = FALSE}
pdf("myPlot.pdf")                   ## Open plot device
plot(y = rnorm(100), x = 1:100)     ## Create graphic with high-level function plot()
dev.off()                           ## Close plot device
```

`plot()` is a function that calls different methods for different objects:

```{r list61, eval = FALSE}
function (x, y, ...)
UseMethod("plot")
<bytecode: 0x55ef0a3b5ec8>
<environment: namespace:graphics>
```

These methods correspond to the available high-level plot functions.

## Types of Plots (High-Level Plots)

-   `barplot()`: Bar chart
-   `pie()`: Pie chart (`plotrix` package includes `pie3d`)
-   `boxplot()`: Box plot
-   `contour()`: Ideal for contour maps, i.e., f: R² -\> R; `filled.contour()` for colored contour maps
-   `coplot()`: Conditioning plot
-   `curve()`: Line plot, allows function input via `curve(f(x))`
-   `dotchart()`: Useful for many factors with one level
-   `hist()`: Histogram
-   `mosaicplot()`: Mosaic plot; useful for compositions over time

---

-   `pairs()`: Useful for correlation analysis
-   `image()`: For drawing images
-   `persp()`: 3D graph drawing, including coordinate axis selection
-   `scatterplot3d()`: Same as above
-   `qqplot()`: Quantile-Quantile plot

------------------------------------------------------------------------

Examples:

```{r list62, eval = TRUE, fig.height= 4, fig.width= 9}
load(url("https://www.dropbox.com/scl/fi/9u8h45ajulcw3qm4ucrn9/CPS1985.RData?rlkey=4f81urvkwjhihyvn88g15o92w&st=nmwi22od&dl=1"))
class(CPS1985)
plot(CPS1985)             ## plot on data.frame calls pairs()
```

------------------------------------------------------------------------

Examples:

```{r list63, eval = TRUE, fig.height= 5, fig.width= 9}
class(CPS1985$wage)
plot(CPS1985$wage)       ## plot on numeric calls plot.default()
```

------------------------------------------------------------------------

Examples:

```{r list64, eval = TRUE, fig.height= 5, fig.width= 9}
class(CPS1985$occupation)
plot(CPS1985$occupation)       ## plot on factor calls barplot()
```

## A Continuous Variable

```{r list65, eval = TRUE, fig.height= 5, fig.width= 9}
par(mfrow = c(1,2))
hist(CPS1985$wage, breaks = 20)
plot(density(CPS1985$wage))
```

## A Discrete Variable

```{r list66, eval = TRUE, fig.height= 5, fig.width= 9}
par(mfrow=c(1,2))
plot(CPS1985$occupation)        ## Generates barplot(table(CPS1985$occupation))
pie(table(CPS1985$occupation))  ## Same information, but not necessarily recommended
```

## Two Continuous Variables

```{r list67, eval = TRUE, fig.height= 5, fig.width= 9}
## Scatterplot as a starting point for most analyses:
plot(x = CPS1985$education, y = CPS1985$wage)
```

## Two Discrete Variables

```{r list68, eval = TRUE, fig.height= 5, fig.width= 9}
## Mosaic plot as a starting point for most analyses:
plot(gender ~ occupation, data = CPS1985)
```

## Continuous Variable Dependent on a Discrete Variable

```{r list69, eval = TRUE, fig.height= 5, fig.width= 9}
plot(wage ~ occupation, data = CPS1985)
```

## Three or More Variables

```{r list70, eval = TRUE, fig.height= 5, fig.width= 9}
## Sequentially
par(mfrow = c(1,2))
plot(wage ~ education + occupation, data = CPS1985)
```

------------------------------------------------------------------------

```{r list71, eval = TRUE, fig.height= 5, fig.width= 9}
## In one plot
coplot(wage ~ education | occupation, data = CPS1985)
```

------------------------------------------------------------------------

```{r list72, eval = TRUE, fig.height= 5, fig.width= 9}
## Four variables in one plot
coplot(wage ~ education | occupation + gender, data = CPS1985)
```

## Customizing Graphics

```{r list73, eval = TRUE, , fig.height= 5, fig.width= 9}
par(mfrow=c(1,2))
hist(CPS1985$education, breaks = 3)  ## Coarsely detailed histogram
hist(CPS1985$education, breaks = 16) ## More detailed histogram
```

------------------------------------------------------------------------

```{r list74, eval = TRUE}
par(mfrow = c(1,2))
plot(CPS1985$wage, type = "p") ## Points
plot(CPS1985$wage, type = "l") ## Lines
```

------------------------------------------------------------------------

```{r list75, eval = TRUE}
# Title and axis labels
par(mfrow = c(1,2))
with(CPS1985, {
  plot(x = age, y = wage,
     main = "Scatterplot of Age and Hourly Wage")
  plot(age, wage,
     xlab = "Age in Years", ylab = "Hourly Wage",
     main = "Scatterplot of Age and Hourly Wage")
})
```

## Fine-Tuning

Not everything can be adjusted via optional arguments in high-level functions; in such cases, `par()` is often used: 
<div style="display: flex; gap: 2em;">
<div style="flex: 1;">

```{r list76, fig.height= 4, fig.width= 5}
par(bg = "yellow")
with(CPS1985,
     plot(age)
)
```

</div> <div style="flex: 1;"> 

```{r list77, fig.height= 4, fig.width= 5}
par(bg = "transparent", cex=0.5)
with(CPS1985,
     plot(age)
)
```

</div> </div>


---

**Overview**: Frequently used arguments in graphic functions. See `?par` for all graphical options


 - `axes`: Axis specification
 - `bg`: Background color
 - `cex`: Factor for scaling relative to the default
 - `col`: Plot color
 - `log`: `xlog` and `ylog` for logarithmic scales
 - `lty`, `lwd`: Line type and thickness
 - `mai`: 4-vector specifying margins (bottom, left, top, right)
 - `main`, `sub`: Title, subtitle
 - `mar`: Margin
  
---

 - `mfcol`, `mfrow`: Multiple plots in one graphics window (column-wise/row-wise)
 - `pch`: Point character (1-16)
 - `usr`: The extreme points for a plot
 - `xlab`, `ylab`: x and y axis labels
 - `xlim`, `ylim`: x and y axis limits



## Low-Level Graphic Functions

 - `lines`: Draw lines
 - `abline`: Quickly add horizontal, vertical lines, and lines using equation $y = bx + a$
 - `points`: Add points
 - `arrows`: Add arrows
 - `polygon`: Draw arbitrary polygons
 - `segments`: Draw unfilled polygons
 - `axis`: Customize axes
 - `grid`: Add a grid

---

 - `rug`: "Density carpet"
 - `title`: Add a title
 - `legend`: Add a legend
 - `text`: Add text at $(x,y)$ coordinates
 - `mtext`: Add text with positional specification like `side=1,...,4`

---

<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list78, eval = FALSE}
attach(CPS1985) ## see ?attach
plot(x = education, y = wage, #<<
     pch = 16, axes = FALSE)  #<<
```

</div> <div style="flex: 1;">

```{r list78a, ref.label="list78", echo=FALSE, fig.height=9}
```

</div> </div>

---

<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list79, eval = FALSE}
attach(CPS1985)
plot(x = education, y = wage,
     pch = 16, axes = FALSE)

# Add axes
ticks <- seq(-100, 100, 0.5) #<<
axis(side = 1, at = ticks,   #<<
     labels = paste(ticks,"y"))

axis(side = 2, at = 
        seq(-100,100, 0.5))#<<
```

</div> <div style="flex: 1;">
```{r list79a, echo=FALSE, fig.height=9}
plot(x = education, y = wage,
     pch = 16, axes = FALSE)
# Axis customization
ticks <- seq(-100, 100, 0.5)
axis(side = 1, at = ticks,
     labels = paste(ticks,"y"), col = "black",
     col.ticks = "black", col.axis = "black", col.lab = "black")
axis(side = 2, at = seq(-100,100, 0.5), col = "black",
     col.ticks = "black", col.axis = "black", col.lab = "black")
```
</div> </div>


---

<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list80, eval = FALSE}
attach(CPS1985)
plot(x = education, y = wage,
     pch = 16, axes = FALSE)

# Add axes
ticks <- seq(-100, 100, 0.5)
axis(side = 1, at = ticks,
     labels = paste(ticks,"y"))

axis(side = 2, at = 
        seq(-100,100, 0.5))

# Add tick marks
rug(wage, side = 2) #<<
```

</div> <div style="flex: 1;">
```{r list80a, echo=FALSE, fig.height=9}
plot(x = education, y = wage,
     pch = 16, axes = FALSE)
ticks <- seq(-100, 100, 0.5)
axis(side = 1, at = ticks,
     labels = paste(ticks,"y"))
axis(side = 2, at = seq(-100,100, 0.5))
rug(wage, side = 2, col = "black")
```

</div> </div>


---

<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list81, eval = FALSE}
attach(CPS1985)
plot(x = education, y = wage,
     pch = 30, axes = FALSE)

# Add axes
ticks <- seq(-100, 100, 0.5)
axis(side = 1, at = ticks,
     labels = paste(ticks,"y"))

axis(side = 2, at = 
        seq(-100,100, 0.5))

# Add tick marks 
rug(wage, side = 2)

# Add regression line 
abline(a = -0.7460, b=0.7505, 
        col="blue") #<<
abline(h = mean(wage), lty=2, 
    col = "red", lwd = 8) #<<
abline(v = mean(education), lty=3, 
    col = "orange", lwd = 4) #<<
```

</div> <div style="flex: 1;">
```{r list81a, echo=FALSE, fig.height=9}
plot(x = education, y = wage,
     pch = 16, axes = FALSE)
ticks <- seq(-100, 100, 0.5)
axis(side = 1, at = ticks,
     labels = paste(ticks,"y"))
axis(side = 2, at = seq(-100,100, 0.5))
rug(wage, side = 2)
abline(a = -0.7460, b=0.7505, col="blue", lwd = 4)
abline(h = mean(wage), lty=2, col = "red", lwd = 8)
abline(v = mean(education), lty=3, col = "orange", lwd = 4)
```

</div> </div>


---



<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list82, eval = FALSE}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
```

</div> <div style="flex: 1;">
```{r list82a, echo=FALSE, fig.height=9}
plot(x = education, y = wage,
     pch = 16)
```

</div> </div>



---


<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list83, eval = FALSE}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),        #<<
      y = c(20, 30, 25),      #<<
      col="darkgreen", lwd = 3) #<<
```

</div> <div style="flex: 1;">

```{r list83a, echo=FALSE, fig.height=9}
plot(x = education, y = wage, 
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
```

</div> </div>



---


<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list84, eval = FALSE}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),        #<<
      y = c(20, 30, 25),      #<<
      col="darkred", pch = 19) #<<
```

</div> <div style="flex: 1;">

```{r list84a, echo=FALSE, fig.height=9}
plot(x = education, y = wage,
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),        #<<
      y = c(20, 30, 25),      #<<
      col="darkred", pch=19) #<<
```

</div> </div>



---


<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list85, eval = FALSE}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkred", pch = 19)
polygon(x = c(3, 3, 10, 8), #<<
        y = c(10,20,20,10), #<<
        col="lightgreen") #<<
```

</div> <div style="flex: 1;">

```{r list85a, echo=FALSE, fig.height=9}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),        #<<
      y = c(20, 30, 25),      #<<
      col="darkred", pch=19) #<<
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10), 
        col="lightgreen")
```

</div> </div>



---


<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list86, eval = FALSE}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkred", pch = 19)
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10),
        col="lightgreen")
arrows(x0 = 10, y0 = 40, x1 = 13.8, #<<
       y1 = 44.2, lwd = 5, #<<
       col = "darkblue")   #<<
```

</div> <div style="flex: 1;">

```{r list86a, echo=FALSE, fig.height=9}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),        #<<
      y = c(20, 30, 25),      #<<
      col="darkred", pch=19) #<<
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10), 
        col="lightgreen")
arrows(x0 = 10, y0 = 40, x1 = 13.8,
       y1 = 44.2, lwd = 5, 
       col = "darkblue")
```

</div> </div>



---


<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list87, eval = FALSE}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkred", pch = 19)
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10),
        col="lightgreen")
arrows(x0 = 10, y0 = 40, x1 = 13.8,
       y1 = 44.2, lwd = 5,
       col = "darkblue")
title("Wage versus Education") #<<
```

</div> <div style="flex: 1;">

```{r list87a, echo=FALSE, fig.height=9}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),        #<<
      y = c(20, 30, 25),      #<<
      col="darkred", pch=19) #<<
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10), 
        col="lightgreen")
arrows(x0 = 10, y0 = 40, x1 = 13.8, #<<
       y1 = 44.2, lwd = 5, #<<
       col = "darkblue")   #<<
title("Wage versus Education") #<<
```

</div> </div>

---


<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list88, eval = FALSE}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkred", pch = 19)
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10),
        col="lightgreen")
arrows(x0 = 10, y0 = 40, x1 = 13.8,
       y1 = 44.2, lwd = 5,
       col = "darkblue")
title("Wage versus Education") #<<
text(x = 11, y = 30, 
    "Text in Plot") #<<
```

</div> <div style="flex: 1;">

```{r list88a, echo=FALSE, fig.height=9}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),        #<<
      y = c(20, 30, 25),      #<<
      col="darkred", pch=19) #<<
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10), 
        col="lightgreen")
arrows(x0 = 10, y0 = 40, 
       x1 = 13.8, #<<
       y1 = 44.2, lwd = 5, #<<
       col = "darkblue")   #<<
title("Wage versus Education") #<<
text(x = 11, y = 30, "Text in Plot")
```

</div> </div>



---


<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

```{r list89, eval = FALSE}
plot(x = education, y = wage,# <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkred", pch = 19)
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10),
        col="lightgreen")
arrows(x0 = 10, y0 = 40, x1 = 13.8,
       y1 = 44.2, lwd = 5,
       col = "darkblue")
title("Wage versus Education") #<<
text(x = 11, y = 30, "Text in Plot")
legend(x="topright", #<<
  legend = c("Data point","Line"), #<<
  lty = c(NA, 1), 
  pch = c(19, NA),   #<<
  lwd = c(1, 3), 
  col = c(1, "darkgreen"))  #<<
```

</div> <div style="flex: 1;">

```{r list89a, echo=FALSE, fig.height=9}
plot(x = education, y = wage, # <<<<<<<<
     pch = 16)
lines(x = c(2, 7, 10),
      y = c(20, 30, 25),
      col="darkgreen", lwd = 3)
points(x = c(2, 7, 10),        #<<
      y = c(20, 30, 25),      #<<
      col="darkred", pch=19) #<<
polygon(x = c(3, 3, 10, 8),
        y = c(10,20,20,10), 
        col="lightgreen")
arrows(x0 = 10, y0 = 40, x1 = 13.8, #<<
       y1 = 44.2, lwd = 5, #<<
       col = "darkblue")   #<<
title("Wage versus Education") #<<
text(x = 11, y = 30, "Text in Plot")
legend(x="topright",
    legend = c("Data point","Line"), #<<
    lty = c(NA, 1), 
    pch = c(19, NA),   #<<
    lwd = c(1, 3), 
    col = c(1, "darkgreen"))  #<<
```

</div> </div>




## Task 3.1

Draw a plot of the function \( f(x) = e^x + 2 \) in the range from -2 to +2, with the line color set to green.  
Create a legend in the upper left corner with the entry \( e^x + 2 \) and the corresponding line.

**Hint**: To include mathematical labels in a legend, you need to use  
"mathematical annotations," which can be found [here](http://stuff.mit.edu/afs/sipb/project/r-project/arch/i386_rhel3/lib/R/library/graphics/html/plotmath.html).  
With `paste()` and `expression()`, this should be straightforward.



## Task 3.2  

Create a scatter plot of `wage` against `education` (from the `CPS1985` dataset),  
where women appear as red points and men as blue points.  
Add a legend to illustrate this distinction.



## Task 3.3  

Try to draw a white, five-pointed star on a red background (e.g., using `polygon()`).  
Save this as a `.pdf` file in the "graphs" folder.

## Task 3.4  

See whether a LLM improves your graph: Write a promt for a LLM of choice to create a scatter plot of `wage` against `education`. Again, distinguish between men and women. Come up with further characteristics you could add, and see if the AI model produces a satisfactory graph. 






# 4. Data Analysis

---
```{r setup, include = FALSE}
url_wheat <- "https://www.dropbox.com/scl/fi/5g9rh2mzmegss9tvnq2bi/wheat.txt?rlkey=9lyvtr6b9jgv120ijtscdl3mu&st=qeipr43d&dl=1"
if (!file.exists("wheat.txt")) system(paste0("wget ", url_wheat))
library(AER)
data(CPS1985)
```

## Consistent Work with Data: tidyverse

In this chapter, we will (superficially) cover the package [dplyr](https://dplyr.tidyverse.org/). This package is part of the [tidyverse](https://www.tidyverse.org/), a collection of R packages designed to provide a consistent approach to working with data. The following packages belong to the [tidyverse](https://www.tidyverse.org/):

 - [dplyr](https://dplyr.tidyverse.org/): "Grammar of Data Manipulation"

 - [ggplot2](https://ggplot2.tidyverse.org/): "Grammar of Graphics"

 - [readr](https://readr.tidyverse.org/): "Fast and friendly way to read rectangular data"

 - [tibble](https://tibble.tidyverse.org/): "A tibble, or tbl_df, is a modern reimagining of the data.frame"

 - [tidyr](https://tidyr.tidyverse.org/): "Create tidy data. Tidy data is data where:
      1. Every column is a variable.
      2. Every row is an observation.
      3. Every cell is a single value."

 - [purrr](https://purrr.tidyverse.org/): "Enhance R’s functional programming toolkit"

---

An important component of working with data and `dplyr` is the pipe operator `%>%`, included in the `magrittr` package. The goal of this operator (also found in many other languages) is to make function composition more readable in code.

Example:
```{r example: pipe-operator, eval = FALSE}
library(dplyr)

f <- function(x) x + 10
g <- function(x) x * 2

a <- 2
f(g(a))         # 2*a + 10 -> 14

## Same result using the pipe operator
a %>% g() %>% f()

## Parentheses for function calls can be omitted,
## but for readability, it is helpful to keep them
a %>% g %>% f
```

---

More examples
<div style="display: flex; gap: 2em;">

<div style="flex: 1;">

**dplyr** with `%>%`
```{r pipe-example, eval = FALSE}
People %>%
  dplyr::select(Age) %>%
  summary()


CPS1985 %>%
  filter(age > 25) %>%
  group_by(gender) %>%
  summarise(mwage = mean(wage))
```

</div> <div style="flex: 1;">

**Standard R**
```{r pipe-eq, eval = FALSE}
summary(
  subset(People, select = Age)
  )

datatemp <- subset(CPS1985, age > 25)
tapply(X = datatemp$wage,
      INDEX = datatemp$gender,
      FUN = mean)
```

 </div> </div>


In the second example, you can already see that the pipe operator often eliminates the need for unnecessary assignments.


## `dplyr`

The key functions of `dplyr` are:

- [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.html): Add new variables to a dataset

- [`select()`](https://dplyr.tidyverse.org/reference/select.html): Select variables (columns)

- [`filter()`](https://dplyr.tidyverse.org/reference/filter.html): Select observations (rows)

- [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.html): Sort observations

- [`summarise()`](https://dplyr.tidyverse.org/reference/summarise.html): Reduce variable values of multiple observations to a single value

- [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.html): Apply subsequent operations to groups

- `join()`: Merge two datasets

These functions often have variants and additional helper functions that assist with variable selection.

---

Datasets that are *tidy* should have each observation as a row and each variable as a column (`long` format). However, datasets are often found in `wide` format.

A way to convert `wide` to `long` is the `pivot_longer()` function from `tidyr`:
```{r wide-to-long, eval = FALSE}
library(tidyr) ## version 1.0.0
data_wide <- data.frame(id = c(1,2,3,4),
                        wage90 = c(12,13,14,11),
                        wage95 = c(14,16,13,18))

data_long <- data_wide %>%
  pivot_longer(cols = starts_with("wage"), # Select columns #<<
               names_to = "year",          # New column name #<<
               values_to = "wage")         # New column for values #<<

class(data_long) # tbl_df, tbl, data.frame
```


## A Single Variable

Measures of central tendency:
```{r da-univariat, eval = FALSE}
## Continuous variable
CPS1985 %>%
  summarise(mean_wage = mean(wage),
            sd_wage = sd(wage),
            med_wage = median(wage),
            min_wage = min(wage),
            q1_wage = quantile(wage,0.25))

## For simple cases, this also works:
summary(CPS1985$wage)

## Discrete variable
table(CPS1985$occupation)
```


## Graphical Representation
```{r plot-univariate, eval = FALSE}
## Lambda expression and dot placeholder
CPS1985 %>%
  mutate(lwage = log(wage)) %>%
  select(lwage) %>% {
    lwage <- .[,1]     # '.' represents the value from the left 
                       # side before the last pipe operator
    hist(lwage)        # Equivalent to CPS1985 %>% select(wage)
  }
```


## Multiple Variables

```{r da-multiple-vars, eval = FALSE}
## Multiple continuous variables
CPS1985 %>%
  select(wage, education, age) %>% {
    pairs(.)
    cor(.)
  }

## Discrete variables (frequency tables)
CPS1985 %>%
  group_by(gender, sector) %>%
  summarise(n = n())

## Alternative:
with(CPS1985,
     ftable(gender, sector)
)
## Or also:
xtabs(~gender + sector, data = CPS1985)
```


## Task 4.1

Use the dataset `CPS1985` from the `AER` package.

1. Add the variable `logW` (log-transformed wages) to the dataset using `mutate()` and the pipe operator.

2. Compute, grouped by `gender` and `occupation`, the mean log wages and their standard deviation.

3. Select the observation with the highest wage for both men and women.

4. Add a variable `lowest_wage_in_occ` to the `CPS1985` dataset, which remains constant within each `occupation` group and corresponds to the lowest wage in that respective group.

5. Sort the dataset within gender groups by wages.

---

## Task 4.2

Enhance the histogram of (log) wages within the lambda expression on [Slide 124](#124) as follows:

1. Add the density function of a normally distributed random variable with the same mean and variance as the log wages.

2. Draw the mean as a dashed line.

3. Use a polygon to shade the area under the density function up to the 25% quantile.


## Task 4.3
The code on the next slide collects climate data for Dutch cities. Use `dplyr` to 

1. find the warmest and coldest day in Maastricht
2. find the city with the highest average temperature in 2023 and the one with the lowest average temperature
3. count the number of rainy days (`I_RAIN_DRIZZLE`) and identify the city with the highest and lowest number of rainy days. 
4. identify the cities with the highest and lowest average rainfall (`PRCP`, hint: use na.rm = TRUE to get rid of the NA values)
5. Modify the code to get a time series for Maastricht only. Plot minimum, maximum and average temperature across time.

---

```{r setup2, eval = FALSE}
# Install if needed
install.packages(c("dplyr", "lubridate", "GSODR"))

# Load libraries
library(dplyr)
library(lubridate)
library(GSODR)
# list of Dutch cities 
cities <- data.frame(
  city = c("Amsterdam", "Rotterdam", "The Hague", "Utrecht", "Eindhoven", "Tilburg", "Groningen", "Almere", "Breda", "Nijmegen", "Enschede", "Haarlem", "Arnhem", "Zaanstad", "Maastricht", "Apeldoorn"),
  lat = c(52.37, 51.92, 52.08, 52.09, 51.44, 51.56, 53.22, 52.37, 51.59, 51.84, 52.22, 52.39, 51.98, 52.45, 50.85, 52.21),
  lon = c(4.89, 4.48, 4.30, 5.11, 5.48, 5.09, 6.57, 5.22, 4.78, 5.85, 6.89, 4.64, 5.92, 4.81, 5.69, 5.97)
)

# Find closest weather stations
cities$stations <- sapply(1:NROW(cities), function(j){
    nearest_stations(cities$lat[j], cities$lon[j], 100) %>% 
    filter(END >= 20240000) %>% 
    .[which.min(distance_km), ] %>%
    pull(STNID)
})
weather_data <- get_GSOD(years = 2023, station = cities$stations)
```
---



## Hypothesis Tests

For this, we use the dataset [wheat.txt](https://www.dropbox.com/scl/fi/5g9rh2mzmegss9tvnq2bi/wheat.txt?rlkey=9lyvtr6b9jgv120ijtscdl3mu&st=r95f4h2x&dl=1), which contains wheat prices for the months from March 1982 to March 2012.

```{r hyp-test, eval = FALSE}
(wheat <- read.table("wheat.txt", header=TRUE) %>%
  na.omit()) %>% {

    ## One-sample t-test
    t.test(.$Change,
       alternative = "greater",
       mu = 0,
       conf.level = 0.95)

    ## Two-sample t-test
    t.test(Change ~ I(Year > 2000), data = .,      ##  t-test specification 
       alternative = "greater",
       mu = 0,
       conf.level = 0.95)
  }

```
---

Other functions to perform hypothesis tests:

- `var.test()`: Test for equality of variances between two vectors
- `chisq.test()`: $χ^2$-test for independence
- Many other packages for specialized tests (`urca`, `lmtest`, `bootUR`)


## Task 4.4

- Skim through the paper ["Incentives Work: Getting Teachers to Come to School"](http://economics.mit.edu/files/5582) by Duflo et al. Briefly describe the experiment that was conducted.

- Then look at the [data](https://dataverse.harvard.edu/dataset.xhtml?persistentId=hdl:1902.1/VZJXRPURTJ). The datasets `TreatmentSchools` and `Posttest` are sufficient.
  Load the data into R and examine it. Try to load the Stata dataset (extension: .dta) using the `read_dta` function from the `haven` package.

---

- In the `Posttest` dataset, create a variable `treat` that takes the value `TRUE` for students whose School-ID (variable `schid`) appears in the `TreatmentSchools` dataset. Use the `%in%` operator for this. 
Example: 
```{r example_2, eval = FALSE}
    a <- 1:10
    a[1:10 %in% c(2,3)]
```

- Create a subset of the dataset that includes only students who took the written test (`post_writ==1`).

- Compare the mean test scores (variable `post_total_w`) of treatment and non-treatment students.

- Conduct a t-test for the following null hypothesis:
   "Treatment and non-treatment students perform equally well on average."



# 5. Flow Control

## General Information

Often, expressions (calculations, estimations, simulations, plots...) should only be executed under certain conditions and/or repeated multiple times. Sometimes an operation is so complex that breaking it down into repeated steps makes it easier to think through and program.

In such cases, we need constructs:

 - Conditional execution (`if`, `else`)
 - Loops (`for`, `while`)
 - Or, as a faster alternative to loops, applying functions to multiple elements simultaneously using different types of `apply()` functions
 - `Vectorize()` modifies functions so they can be applied to multiple elements at once


## Conditional Execution

```{r ifelse, eval = FALSE}
if ( expr ) {
  ## some code evaluated if is.logical(expr) == TRUE
} else {
  ## some other code
}
```

The entire construct is still an expression and therefore has a value (specifically, the value of the last evaluated expression):

```{r ifelse_example, eval = FALSE}
result <- if ( 2 > 1 ) {
  2       ## last evaluated expression
} else {
  1
}   ## result has the value 2
```

---

Be cautious with vector-valued expressions:

```{r ifelse_vector, eval = FALSE}
y <- c(5, 3, 2)
y > 3

if(y > 0) "Here!"   ## only evaluates the first entry of y
```

If you want to check whether all elements of a vector satisfy a certain property, the quantifiers `any()` and `all()` are useful:

```{r ifelse_quantor, eval = FALSE}
if ( all(y > 0) )         ## all() is "TRUE" if the argument is a vector of all TRUE values
{
    print("All y values are greater than 0")
}
else {
    print("At least one element of y is less than or equal to 0!")
}
```

---

Of course, there may be more than two cases to consider, for example:

$$f(x) = \cases{0 \text{ for  } x \leq 5\\
                4 \text{ for  } 0< x \leq 5\\
                6 \text{ otherwise.}}$$
```{r ifelse_more, eval = FALSE}
stepfunction <- function(x){
  if ( x <= 0 ) {
      0
  } else if (x <= 5 ) {
      4
  } else {
      6
  }
}
```

---

Another option is the `switch(expr, ...)` function:

```{r switch, eval = FALSE}
## integer expr
switch(1, "first", "second", "abc")     ## -> "first"
switch(2, "first", "second", "abc")     ## -> "second"
switch(3, "first", "second", "abc")     ## -> "abc"

## character expr
switch("abc", a = "first", b = "second", abc = "mix")  ## -> "mix"
```

---

Sometimes we want to check vectorized objects and return a separate value for each entry. For this, we use the `ifelse()` function:
```{r ifelse_vectorized, eval = FALSE}
x <- c(3, NA, 2)
ifelse( is.na(x), "Missing", "Not Missing")

## absolute value
x <- c(-3, 5, -8, 2)
ifelse( x < 0, -x, x)
```


## Task 5.1

Write a function `if_test` that takes two objects, `x` and `y`, and checks whether `x` is numeric and `y` is of type character.
If both conditions are met, the function should print "Super"; otherwise, it should indicate which of the two objects `x`/`y` does not meet the required condition.

Test your function with:
```{r ex_5.1_test, eval = FALSE}
if_test(5, "char")

if_test("abc", 2)

if_test(list(1,2), matrix("a", 3, 3))
```
Hint: Use `is.character()` and `is.numeric()`.



## Loops

Frequently, small code blocks need to be executed multiple times. Loops help with this. In R, there are three types of loops:

- `repeat{ Code }`: A loop that executes `Code` indefinitely and must be stopped with `break`.

- `while( Condition) { Code }`: The code `Code` executes as long as `is.logical(Condition)` evaluates to `TRUE`.

- `for (value in values) { Code }`: The code `Code` runs once for each element in the vector `values`. The variable `value` takes on the value of each element during each iteration.

In addition to `break` (which terminates the loop), there is another control command: `next` (which immediately jumps to the next iteration of the loop).

---


Examples
```{r example_loops, eval = FALSE}
vec <- c("One","Two","Three")
for (v in vec) print(v)

for (i in 1:10) {
  print(i + 2)
}
```
The following would yield the same result as the latter for loop:
```{r forloop_equiv, eval = FALSE}
i <- 1
print(i + 2)
i <- 2
print(i + 2)
# ...
i <- 9
print(i + 2)
i <- 10
print(i + 2)
```
---

Expressions in constructs are evaluated in the environment in which they are called. Thus, the variable `i` has the value 100 after executing the loop:
```{r for-loop-demo, eval = FALSE}
for (i in 1:100) {
  ## some code using the variable i
}
```
All these constructs can, of course, be freely combined:
```{r cntrol_flow_combined, eval = FALSE}
control <- TRUE
while (control){
  if (a > b){
    for (i in seq(along = longObject)){
      ## do something with i
    }
    if (error) break
  } else {
    next
  }
}
```



## Example: Numerical Optimization of a Function

Algorithmic idea (very naive, thus not suitable for practical use):<br>
We want to numerically find the maximum of a downward-opening parabola.
We start at a value where we are sure that the parabola is still increasing,
move stepwise to the right while checking whether the value of the parabola
is still increasing significantly. If this is not the case, we stop:
```{r parabel, eval =TRUE, fig.height=5, echo = FALSE}
parabel <- function(x) -x^2
par(mar = c(3,2,0,0))
plot(parabel , -2,2, xaxt = "n", yaxt = "n")
axis(side = 1, at = c(-1.7,-1.3,-0.9,-0.5), tick = TRUE,
     labels = c("x1","x2", "x3", "x4"))
axis(side = 2, at = parabel(c(-1.7,-1.3,-0.9,-0.5)), tick = TRUE,
     labels = c("y1","y2", "y3", "y4"))
x <- c(-1.7,-1.3,-0.9,-0.5)
y <- -x^2
xx <- unlist(lapply(x, function(x) c(x,x, par()$usr[3], NA)))
yy <- unlist(lapply(y, function(x) c(par()$usr[3],x,x, NA)))
lines(x = xx, y = yy, lty = 2, col = "blue")
points(x,y, pch = 19, col = "blue")
```


---

Code:
```{r num_optim, eval = FALSE}
parabel <- function(x) -x^2

xx <- -2          ## here we start
yy <- parabel(xx) ## what is the value of the parabola here?

dY <- 1           ## we initialize a value so that while() does not terminate immediately
while( dY > 0.0000001){
  xx <- xx + 0.01       ## move xx one step to the right
  yyNew <- parabel(xx)  ## what is the value of the parabola at the new xx?
  dY <- yyNew - yy      ## by how much did the value of the parabola increase in this step?
                        ## this dY is used before the next loop iteration to check
                        ## whether the condition dY >0.0000001 is still met.
  yy <- yyNew           ## make yy the new value for the next loop iteration
}
```
---



## Task 5.2

1. Compute the matrix product of A and B without using the `%*%` operator.
    Use one or more loops and something like <br>`sum(A[1,] * B[,1])` for `C[1,1]`, etc.
```{r exc5.1, eval = FALSE}
A <- matrix(1:12,4,3)
B <- matrix(1:9,3,3)
C <- A %*% B
```
    

2. Now create a function `mat_mult` from the loops of the previous subtask,
   which, when given two matrices, computes their product but first checks with `if`
   whether the row length of one matrix matches the column length of the other matrix.
   Test this with the matrices above.



## Task 5.3

- Write a function `optimizer` that, when given a (real-valued) function, numerically searches for its optimum. Use the example code above.

- Instead of the optimization method used above, try implementing a bisection method.
  See the Wikipedia article on the [Bisection Method](https://en.wikipedia.org/wiki/Bisection_method).<br>
Hint: To compute the derivative of a function `fun` at a point `x`,
you can use the function `numericDeriv()` from the `stats` package as follows:

```{r compute_numderiv, eval = FALSE}
env.o2 <- new.env()
dfun <- function(x) {
    assign("x",x, envir = env.o2)
    attr(numericDeriv(quote(fun(x)), "x", rho = env.o2), which = "gradient")[1,1]
}
```



## apply Constructs

Loops in R are relatively slow and can sometimes lead to less readable code. Where possible, loops should be avoided. Often, a loop can be replaced by vectorization (with extreme performance gains since loops are then executed in C rather than in R).

In addition, R provides a family of `apply` constructs that enable vectorized operations.

---

For working with matrices and arrays, the `apply()` function is available. This function can apply suitable functions to rows or columns.
```{r apply-demo, eval = FALSE}
A <- matrix(c(2, 6, 3, 4, 5, 7, 8, 4, 1), ncol = 3)
 ## row-wise maximum:
apply(X = A,            ## an array or a matrix
      MARGIN = 1,       ## Over which indices should the function be applied
                        ##  (1 -> rows, 2 -> columns)
      FUN = max         ## which function should be applied?
)

X <- rnorm(1000) %>%
  matrix(ncol = 10)

apply(X, 2, var)        ## Variances of the columns
```

---

Often, lists are available, and a function needs to be applied to each element, returning a list as a result. The `lapply()` function serves this purpose.

```{r lapply-demo, eval = FALSE}
List <- list(a=c(4,8,7),
  b=seq(0,100,5),
  c=c(TRUE,TRUE,FALSE,TRUE)
)

ListSum <- lapply(List, sum)
class(ListSum)            ## returns a list
```

Often, the result does not need to be a list but rather a vector (or a matrix/array). This is achieved using `sapply()`:
```{r sapply-demo, eval = FALSE}
ListSum <- sapply(List, sum)
class(ListSum)           ## "numeric"
```

---

All members of the apply family accept the `...` argument, allowing additional parameters to be passed to the function:

```{r apply-dots, eval = FALSE}
## custom function
funnyFun <- function(x, m, std) sum(x)/( 2 * rnorm(1, mean=m, sd=std))

## using `...` to pass 'm' and 'std' to funnyFun:
sapply(X=List, FUN=funnyFun, m=2, std=5)

## also works for plotting:
par(mfrow=c(length(List),1))
lapply(List, plot, main="Title", type="l", lwd=2)
```



## Task 5.4

Create a $10\times 10$ matrix where the $ij$-th element is given by $(i\cdot j)^{(1/j)}$. Use two nested loops for this. Then, compute the row and column sums of this matrix using an `apply` function of your choice.



## Additional Useful Language Elements

Sometimes, objects need to be created dynamically with names dependent on other variables and later retrieved. This cannot be done using `<-`. Therefore, R provides the functions `assign()` and `get()`.

```{r assign-demo, eval = FALSE}
objectName <- "x"

## The following assignments are equivalent:
x <- 2
assign("x", 2)
assign(objectName, 2)

## Retrieve the value of object "x"
get(objectName)   ## -> 2
```

---

Further example:
```{r assign-example, eval = FALSE}
## Depending on the value of x, either mean() or sum() is executed
myFunc1 <- mean
myFunc2 <- sum

x <- 1
get(paste("myFunc",x,sep=""))(1:10)     ## mean()
x <- 2
get(paste("myFunc",x,sep=""))(1:10)     ## sum()
```

---

Another example demonstrating the usefulness of `assign()`: <br>
Store the `summary()` output of each variable in the `CPS1985` dataset as `summary_{VariableName}`.
```{r assign-variable-name, eval = FALSE}
names(CPS1985)
for(variable in names(CPS1985))
{
    assign(paste("summary_", variable, sep = ""), summary(get(variable)))
    print(paste("summary_", variable, sep = ""))
}
```

What exactly is happening here?
---

Break it down step by step:

```{r assign-var-detail, eval = FALSE}
## Loop iterates over values:
names(CPS1985)

## First iteration:
variable <- names(CPS1985)[1]
variable
get(variable)
summary(get(variable))
paste("summary_", variable, sep = "")
assign(paste("summary_", variable, sep = ""), summary(get(variable)))
```



## Error Handling

Often, it is not known in advance whether executing code will result in errors.

- One option: Check all cases that might lead to errors before execution.
- Another (pragmatic) approach is to use language elements for **error handling**, which are present in many programming languages:

```{r tryCatch, eval = FALSE}
value <- tryCatch({
  ## some code to be evaluated
  expr
}, warning = function(w){
  ## code evaluated if evaluating expr leads to a warning
  print(w)
}, error = function(e){
  ## code evaluated if evaluating expr leads to an error
  print(e)
})
```



## Recursion

Sometimes quite useful: recursive functions.

```{r factorial , eval = FALSE}
factorial <- function(n){
  if (n<0) stop("Factorial only for positive integers")

  if (n<2) return(1)

  n * factorial(n-1)
}
```



## Task 5.5

 1. Replace the loop over the variable with an apply construct.
 2. How can the use of `assign` and `get` be avoided for this problem?

## Task 5.6

Write a function named "fib" that, given a natural number `n`, computes the `n`-th Fibonacci number. The Fibonacci sequence is defined recursively as follows:

$a_0=0$, $a_1=1$, and $a_n=a_{n-1}+a_{n-2}$.





# 6. Regression

## General Information

In econometrics (which can also be applied to other scientific fields), we often ask questions like:
 - Does income convergence occur (does a low income level lead to higher growth in the future, ceteris paribus)?
 - Is education an important determinant of growth?
 - Does foreign trade accelerate growth?
 - Is political stability important / does violence hinder economic prosperity?
 - Is growth slower in Africa, ceteris paribus?

The standard tool for such analyses: **multiple linear regression model**

 $$y_i = \beta_0 + \beta_1 x_{1,i} + \beta_2 x_{2,i} + \dots + \beta_p x_{p,i} + u_i,\ i=1,\dots,n$$
Or, in matrix notation:
$$\mathbf{y} = \mathbf{X}\beta + \mathbf{u},$$
where $\mathbf{y}, \mathbf{u}\in\mathbb{R}^{n}$, $\mathbf{X}\in\mathbb{R}^{n\times k}$, $\beta\in\mathbb{R}^{k}$, and $k = p + 1$.


## Formula Objects

R is designed to easily estimate various statistical models. It provides a specific object class to symbolically describe statistical models, called `formula` objects. See `?formula` for more details.

Example: the regression model

$y_i = \beta_0 + \beta_1 x_{1,i} + \beta_2 x_{2,i} + u_i$

can be specified in R as a `formula` like this:

`y ~ x1 + x2`

---

- Important operators:
  - `~`: Basis for all models. `y ~ model` specifies that the dependent variable `y` is modeled using the linear predictors described in `model`.
  - `+`: Models consist of terms separated by `+` (in simple cases, these are variables).
  - `:`: Creates interaction terms between variables.
  - `*`: `a*b` is equivalent to `a + b + a:b`.
  - `^`: `(a + b)^2` is equivalent to `(a + b) * (a + b)`.

- Note: `y ~ x1 + x2^2` is NOT the model $y_i = \beta_0 + \beta_1 x_{1,i} + \beta_2 x^2_{2,i} + u_i$!

- For arithmetic expressions (e.g., variable transformations), use the function `I()`: <br>`y ~ x1 + I(x2^2)`.

- Factor variables in formulas are automatically *dummy coded*.

---

The standard function for estimating linear models is `lm()`. This function returns an `lm` object with numerous available methods: `summary()`, `plot()`, `predict()`, etc.

```{r lm_example11, eval = FALSE}
library(AER)
data(GrowthSW)

growth.eq1 <- lm(growth ~ rgdp60,
                 data=GrowthSW)
summary(growth.eq1)
```

---

Output:

```{r lm_example12, eval = TRUE, echo = FALSE}
library(AER)
data(GrowthSW)

growth.eq1 <- lm(growth ~ rgdp60,
                 data=GrowthSW)
summary(growth.eq1)
```
---

Multiple variables, transformations:
```{r lm_example21, eval = FALSE, echo = TRUE}
growth.eq2 <- lm(growth ~ rgdp60 + tradeshare +
                 education + I(education^2) + # education linear and squared
                 revolutions + assassinations, data = GrowthSW)
sum.eq2 <- summary(growth.eq2)
```

Without intercept:
```{r lm_example31, eval = FALSE}
growth.eq3 <- lm(growth ~ -1 + rgdp60 + tradeshare, data = GrowthSW)
```

All variables in the dataset:
```{r lm_example32, eval = FALSE}
growth.eq4 <- lm(growth ~ ., data = GrowthSW)
```

Excluding specific variables:
```{r lm_example33, eval = FALSE}
growth.eq5 <- lm(growth ~ . -rgdp60, data = GrowthSW)
```

---

With factor variable:
```{r lm_example41, eval = FALSE}
GrowthSW <- GrowthSW %>%
  tibble::rownames_to_column("country") %>%
  mutate(continent = factor(ifelse(
    country %in% c("Zaire","Niger","Senegal", "Zimbabwe" ,"Togo",
           "South Africa", "Sierra Leone" ,"Ghana","Kenya",
           "Mauritius"), "africa", "other"), levels = c("africa", "other")))

growth.eq6 <- lm(growth ~ rgdp60 + tradeshare + continent, data = GrowthSW)
summary(growth.eq6)
```

Interaction terms:
```{r lm_example51, eval = FALSE}
growth.eq7 <- lm(growth ~
                     log(rgdp60) * continent +
                     tradeshare+log(education)+
                     revolutions+assassinations,
                 data=GrowthSW)
sum.eq7 <- summary(growth.eq7)
```



## Accessing Regression Results

- Use functions such as `coefficients()`, `fitted()`, `residuals()`.
- Or directly access the `lm` or `summary.lm` list objects:

```{r access_lm, eval = FALSE}
str(growth.eq7)    ## structure of lm object
str(sum.eq7)       ## structure of summary.lm object

# elements in lm object
growth.eq7$coefficients
growth.eq7$residuals
growth.eq7$fitted

# summary.lm provides additional information:
sum.eq7$coefficients      ## matrix with estimates, std-dev, t-stat, p-value
sum.eq7$sigma             ## residual standard error estimate
sum.eq7$adj.r.squared     ## adjusted R^2 of regression
```



## Model Selection

To determine which model is "better," model selection criteria like AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion) are commonly used. The model with the lowest value is considered the "best."

```{r model_selection, eval = FALSE}
# Akaike Criterion
AIC(growth.eq5)     # smaller is better
AIC(growth.eq1)

# Bayesian Information Criterion
BIC(growth.eq5)     # smaller is better
BIC(growth.eq1)
```

---

The `MASS` package provides the `stepAIC` function, which iteratively finds an "optimal" model starting from a large model:
```{r stepwise, eval = FALSE}
install.packages("MASS")
library(MASS)
?stepAIC
growth.eqAIC <- stepAIC(lm(growth ~ (log(rgdp60) + tradeshare + log(education)+
                                      revolutions + assassinations + continent)^2,
                            data=GrowthSW))
```


## Task 6.1
Use the Growth dataset from above.

 1. Test a few possibilities for formula input:
   
    - With and without a constant
    - Quadratic, cubic, or duplicated regressors
    - Interactions (of groups)
    - Use the `stepAIC()` function
  
 2. Select one of your models and apply the `summary()` method to it. Discuss the estimates, standard errors, p-values, residual sum of squares, and the adjusted $R^2$ value.


## Model Diagnosis and Tests
### 1. Heteroskedasticity
Graphical examination:
```{r step_aic1, eval = FALSE}
uhat_AIC <- resid(growth.eqAIC) # growth.eqAIC$residuals
yhat_AIC <- fitted(growth.eqAIC)
plot(yhat_AIC,uhat_AIC^2, main="Squared Residuals vs. Fitted Values")
```

```{r prepare_data, include = FALSE}
library(dplyr)
GrowthSW <- GrowthSW %>%
  tibble::rownames_to_column("country") %>%
  mutate(continent = factor(ifelse(
    country %in% c("Zaire","Niger","Senegal", "Zimbabwe" ,"Togo",
           "South Africa", "Sierra Leone" ,"Ghana","Kenya",
           "Mauritius"), "africa", "other"), levels = c("africa", "other")))
library(MASS)
growth.eqAIC <- stepAIC( lm(growth ~ (log(rgdp60) + tradeshare + log(education)+
                                       revolutions + assassinations + continent)^2,
                            data=GrowthSW))
uhat_AIC <- resid(growth.eqAIC) # growth.eqAIC$residuals
yhat_AIC <- fitted(growth.eqAIC)
```

```{r step_aic, echo = FALSE, fig.height=4}
plot(yhat_AIC,uhat_AIC^2,main="Squared Residuals vs. Fitted Values")
```

---

Heteroskedasticity tests (Breusch-Pagan, White):
```{r test_hetsked, eval = FALSE}
# Breusch - Pagan
bptest(growth.eqAIC)

# White Test
summary(lm(I(uhat_AIC^2)~ yhat_AIC + I(yhat_AIC^2))
        )$r.squared * length(yhat_AIC) %>%
  pchisq(df = 2, lower.tail = FALSE)
```

Solution: Heteroskedasticity-robust variance-covariance matrix
```{r hetskedasty_vcov, eval = FALSE}
vcov.robust <- vcovHC(growth.eqAIC, type = "HC")
coeftest(growth.eqAIC,vcov=vcov.robust)
```

---

### Model Diagnosis: 2. Nonlinearity

```{r lm_nonlinear, fig.height= 4}
plot(yhat_AIC,uhat_AIC,main="Residuals vs. Fitted Values")
```

---

RESET Test:
```{r reset-test, eval = FALSE}
resettest(growth.eqAIC)
```

Additional diagnostic plots:
```{r lm-plot, eval = FALSE}
plot(growth.eqAIC)
```

---

### Hypothesis Testing

- Decisions on simple hypotheses of the form $H_0: \beta_j = 0$ can be directly read from the output
- Similarly: Overall F-test
- Further hypotheses (e.g., $H_0: \beta_j = 3$) or composite hypotheses can be tested using the `linearHypothesis()` function from the `car` package:

```{r linear_hyp, eval = FALSE}
## Symbolic notation:
linearHypothesis(growth.eqAIC, "log(education)=2")

## Alternative form of hypothesis: R %*% beta = r  (where R is a 1xk vector, r is scalar)
R <- c(0,0,0,1,0,0,0,0,0)   # 4th entry selects the 4th coefficient
r <- 2                      # .. which should be 2 according to H_0
linearHypothesis( growth.eqAIC , hypothesis.matrix =R, rhs=r )

## Heteroskedasticity-robust test:
linearHypothesis(growth.eqAIC,"log(education)=2",vcov=vcov.robust)
```

---

### Multiple Hypothesis Testing (F-Tests)
```{r f-test, eval = FALSE}
## Symbolic notation
linearHypothesis(growth.eqAIC,
                 c("log(rgdp60)=0","log(rgdp60):assassinations=0"))

## Using the formulation R %*% beta = r:
R <- matrix(c(0,1,rep(0,7), rep(0,7),1,0),nrow=2, byrow=TRUE)
r <- c(0,0)
linearHypothesis(growth.eqAIC,R,r)
```

### Confidence Intervals
```{r confint, eval = FALSE}
confint(growth.eqAIC,parm=c("revolutions"),level=0.9)
```


## Prediction

```{r prognose, eval = FALSE}
## New observations
X0 <- data.frame( growth=c(NA,NA),
                  revolutions=c(0.3,0.13),
                  rgdp60=c(2000,6000),
                  tradeshare=c(0.3,0.7),
                  continent=factor(c("africa","other"),
                                   levels=c("other","africa")),
                  assassinations=c(0.4,0.2),
                  education=c(2,4)  )

rownames(X0) <- c("Country 1", "Country 2")

## Point prediction, prediction interval, etc.
predict(growth.eqAIC, newdata=X0, se.fit=TRUE, interval="prediction")
```



## Task 6.2

- Use the `CPS1985` dataset to specify and estimate an ad-hoc regression model for the logarithm of hourly wages.
- Starting from a very general model, perform model selection by iteratively removing the least significant regressor. Then, test the exclusion restrictions applied in the process.<br>
  **Hints:**
   - General model: Use a squared formula for all possible interactions.
   - Implement a loop that checks whether the maximum p-value is greater than 5%.
   - Remove the respective regressor from the model. Important: To simplify the removal of individual regressors, ensure that the model outputs matrix X using `lm(y~x, x=TRUE)`. The design matrix `X` can then be accessed via `a$x` when `a <- lm(y~x, x=TRUE)`.

---

- Compare the two models using appropriate diagnostic tests, criteria, and graphical representations. Decide on the better model.
- Estimate the expected wage for an employee whose explanatory characteristics correspond to the median values. Also, determine the expected wage for an "average worker."<br>
  **Hint:** Use a model that includes only numerical explanatory variables.
- Provide a prediction interval for both cases.
  


## Some Rules for Efficient Code

- **Vectorize!** This ensures that loops are executed in C rather than in R.

- **Do not dynamically increase object size in loops**; instead, initialize an empty object first and then populate it.

- Some R functions have significant *overhead* to handle various cases. Often, there are more specific, faster alternatives, such as:
  - `lm()` vs. `lm.fit()` or `.lm.fit()`

- Use **profiling methods** to identify where execution time is high and where optimization may be worthwhile.

- If necessary, implement **bottlenecks in C/C++ or Fortran**.

- Balance **faster execution time vs. extra implementation time** for optimizations.


# Thanks!
Slides created via  [**Quarto**](https://quarto.org), a multi-language version of R Markdown that uses knitr to execute Rmd files.

The chakra comes from [remark.js](https://remarkjs.com), [**knitr**](http://yihui.name/knitr), and [R Markdown](https://rmarkdown.rstudio.com).










