{
  "hash": "3f6ef29709607d97cdea3fdaf76fecd3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Programming in R\"\nsubtitle: \"[hyperlink to presentation]()\"\nauthor: \"fill presenter names here\"\nformat:\n  revealjs:\n    theme: \"theme.scss\"\n    transition: fade\n    background-transition: fade\n    highlight-style: ayu-mirage\n    fontsize: 2em\ncode-link: true\nexecute:\n  echo: true\n  freeze: auto\n\n---\n\n\n\n# Course Overview\n\n1.  [Introduction](#intro)\n2.  [Objects in R](#objects)\n3.  [Graphics](#graphics)\n4.  [Data Analysis (dplyr)](#dataanalysis)\n5.  [Programming: Flow Control](#flowcontrol)\n6.  [Regressions](#regression)\n7.  [Monte Carlo Simulations](#mc)\n8.  [Numerical Optimization](#optim)\n9.  [Bootstrap](#bootstrap)\n10. [Efficiency](#efficiency)\n\n# Preliminary Remarks\n\n## Infrastructure\n\nYou'll need a\n\n-   Personal computer with a current installation of R and RStudio\n    -   Go to [CRAN](https://cran.r-project.org/) to download the appropriate version for your operating system.\n    -   Follow the installation instructions provided on the website.\n    -   Install RStudio from [RStudio](https://posit.co/download/rstudio-desktop/) for a user-friendly interface.\n-   Folder structure consistent with the course:\n    -   `code/`\n    -   `RData/`\n\n## Literature/Links\n\n-   Kleiber, C. & Zeileis, A. (2008), [Applied Econometrics with R](https://www.springer.com/de/book/9780387773162), Springer.\n\n-   Braun, J. & Murdoch, D. (2021), [A first course in statistical programming with R](https://www.murdoch-sutherland.com/StatProg3/index.html)\n\n-   Wickham, H. (2019) [Advanced R](https://adv-r.hadley.nz/)\n\n-   Wickham, H. & Grolemund, G. (2017), [R for Data Science](https://r4ds.had.co.nz/)\n\n-   Verzani, J. (2014), [Using R for Introductory Statistics](https://www.crcpress.com/Using-R-for-Introductory-Statistics/Verzani/p/book/9781466590734)\n\n-   Matloff, N. (2011), [The Art of R Programming](https://nostarch.com/artofr.htm)\n\n-   Wickham, H. (2023) [R Packages](https://r-pkgs.org)\n\n-   Course website: [tbd](tbd)\n\n-   [R project](https://www.r-project.org/)\n\n-   Any further references?\n\n## Learning Goals:\n\n-   Introductory knowledge in R and RStudio\n-   Sufficient knowledge to help yourself\n-   Loading, describing and manipulating data\n-   Descriptive statistics\n-   Visualization\n-   Model estimation\n-   Baseline programming knowledge\n\n## Exam\n\n-   Provide information about the exam here\n\n# 1. Introduction\n\n------------------------------------------------------------------------\n\n## General Information\n\n**R** is...\n\n-   a free implementation of the **S** programming language with the goals:\n    -   Interactive data analysis\n    -   Making it easy for users to become programmers\n    -   Creating graphics for data analysis\n    -   Easy reusability of existing functions\n-   a *interpreted* language (interpreted by the R interpreter at runtime)\n-   a *functional* language (functions are first-class objects)\n-   an *object-oriented* language (classes and methods)\n-   a *vectorized* language (objects are internally represented as vectors)\n\n## Advantages of R\n-   Free (open-source, GPL2/3) software; all code can be inspected and verified\n-   Very close to (statistical) research\n-   Easily extendable through packages\n-   Runs on almost all platforms\n-   Widely applied\n-   Similar to other OOP languages in statistics (Python, Matlab, Julia)\n\n## Disadvantages of R\n\n-   No graphical user interface (but RStudio / Emacs + ESS / VS Code)\n-   No interactive graphics (but Shiny)\n-   Interpreted language, sometimes slower compared to compiled languages.\n-   But: Compiled code (C/C++, Fortran) can be integrated to overcome this. Either via `Rcpp` (fast, user-friendly) or by calling C / Fortran routines directly (faster, less user-friendly)\n\n## First Steps\n\n-   Input *expressions* into the R console (the interpreter), execute with *Return*\n-   Use arrow keys <em>(↑, ↓)</em> to recall previously entered *expressions*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n> sin(2*pi)\n> 2 - 1\n> 0/0         # -> NaN (not defined)\n> Inf-Inf     # -> NaN (not defined)\n> 2 + 3*4     # Operator precedence\n> 2 + \n+ 1       # Execution only when expression is complete\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2.449294e-16\n[1] 1\n[1] NaN\n[1] NaN\n[1] 14\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n## Graphics: {#graphics}\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\nx <- runif(100)\ny <- x + rnorm(100, sd = 0.1)\nplot(x,y)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nWhile many simple calculations can be done using the command line, as soon as things get more complicated, *scripts* should be used.\n\nA script is a text file (usually with a '.R' file extension) that contains R code. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Change working directory\nsetwd(\"C:/Users/Max/R-Code\")\n\n## Load data\nmyData <- read.table(\"all_important_data.csv\",\n                     sep = \";\", header = TRUE)\n\n## Summary\nsummary(myData)\n```\n:::\n\n\n\n## Editors\n\nText files are edited using text editors. There are several editors that make working with R easier:\n\n-   R-Studio (used in this course)\n    -   Closest to a GUI\n    -   Plots, overview of objects and packages in one window\n    -   Extra-click functions like loading data\n    -   Highly recommended for beginners\n-   Notepad++ in connection with npptor (Notepad++ to R)\n    -   Flexible editor for various programming languages, text files, etc. (one editor for multiple languages?)\n    -   Extremely functional as an editor: add-ons, macros, hotkeys, etc.\n    -   Comfortable indentation, highlighting, commenting and uncommenting\n\n------------------------------------------------------------------------\n\n-   (X)Emacs with ESS / VS Code with R extension\n    -   Extremely versatile and powerful editor, though it requires some learning\n    -   Highly customizable\n    -   Works on all platforms\n    -   Suitable for various applications (LaTeX, email, git, etc.)\n\n## RStudio\n\n-   Structure: 4 windows\n\n    -   Top left: Code editor, data.frame view (**Ctrl + 1**)\n    -   Bottom left: R console (**Ctrl + 2**)\n    -   Top right: Display of objects in the global environment (**Ctrl + 8**), history (**Ctrl + 4**)\n    -   Bottom right: Help (**Ctrl + 3**), plots (**Ctrl + 6**), packages (**Ctrl + 7**), etc.\n\n-   Individual windows can now also be detached from the main window\n\n-   To execute code from the editor:\n\n    -   Place the cursor in the respective line\n    -   Press **Ctrl + Enter** → Cursor jumps to the next line\n\n## Getting Help on a Topic\n\nTo get help on a *known* function, you can either search for the function in the RStudio help tab or enter the following in the R console:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?getwd\n```\n:::\n\n\n\n<br> <img src=\"figures/getwd-help.png\" style=\"width: 60%\" align=\"center\"/> \n\n## Getting Help on a Topic\n\nIf you are looking for an *unknown* function (e.g., a function that performs a t-test), the best approach is to use Google, e.g.:\n\n<img src=\"figures/google-search.png\" style=\"align:center;width: 100%\"/>\n\nAs a more recent alternative, consult a LLM but make sure to check the proposed solution for errors\n\n## Getting Help on a Topic\n-   Each package has its own documentation (includes help files), often with vignettes (more detailed explanations)\n-   Stack Overflow\n-   Mailing lists such as R-help\n\n## R as a Calculator\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 2          # -> 3\n1 + (2 * 4)    # -> 9\na <- 3\nb <- 3 * a     # -> 9\nsqrt(b)        # -> 3\n```\n:::\n\n\n\n-   Basic operators: +, -, \\*, /, \\^\n-   Extreme values: min(), max(), abs()\n-   Square roots: sqrt()\n-   Rounding: round(), floor(), ceil()\n-   Trigonometric functions: sin(), cos(), tan(), asin(), acos(), atan()\n-   Logarithms: log(), log2(), log10(), exp()\n-   Sum, product: sum(), prod()\n\n## Functions\n\nWhenever something *happens*, functions are called. All operators, control flows, etc., are functions in R.\n\n-   A function is called by specifying the function name followed by one or more comma-separated arguments in parentheses: `function_name(argument1 = value1, argument2 = value2,...)`\n\n-   Argument names do not always need to be specified: `function_name(value1, value2,...)`\n\n-   Attention: Order matters!\n\n-   There are also default arguments, which do not always need to be specified. More on this later.\n\n## Assignment\n\nThe symbol `<-` is the assignment operator, storing the value of the expression on the right into the variable on the left:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- (3 * 4)\n(3 * 4) -> a    # Also possible but not recommended\na = (3 * 4)     # Also frequently used but not equivalent to '<-'\na<-(3*4)        # Poor readability\n```\n:::\n\n\n\n-   For readability, always include spaces around the assignment operator.\n-   Variable names must start with a letter but may contain numbers, periods, and underscores.\n-   It is recommended to use a consistent naming convention for objects — more on this later.\n\n## Logical Operators\n\n-   Comparison: ==, !=, \\>, \\<, \\>=, \\<=\n-   Logical expressions: TRUE, T, FALSE, F, NA\n-   Operators: ! (Negotiation), xor() (exclusive or), & && (and), \\| \\|\\| (or), all(), any()\n\nExamples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE & FALSE   # FALSE\nTRUE & TRUE    # TRUE\nTRUE | FALSE   # TRUE\n!TRUE | FALSE  # FALSE\nFALSE && TRUE  # Second TRUE is not evaluated\nTRUE && TRUE   # Second TRUE is evaluated\nTRUE || FALSE  # Second FALSE is not evaluated\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\nMore Examples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(TRUE, FALSE) & c(TRUE, TRUE)  # [1] TRUE FALSE   -> Vectorized\nc(TRUE, FALSE) && c(TRUE, TRUE) # [1] TRUE         -> Not vectorized\n```\n:::\n\n\n\nQuantifiers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(TRUE, FALSE, TRUE)\nb <- c(TRUE, TRUE, TRUE)\nany(a)         # [1] TRUE\nall(a)         # [1] FALSE\nall(b)         # [1] TRUE\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\nMissing Values:\n\nTesting for `NA` is only possible with `is.na()`. `x == NA` always returns `NA`!\n\nExamples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(TRUE, NA, TRUE)\na == NA           # [1] NA NA NA\nis.na(a)          # [1] FALSE TRUE FALSE\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\n## Useful Functions:\n\n-   `ls()` displays existing objects in the global environment\n-   `str()` shows the structure of an object\n-   `rm()` removes an object from the global workspace\n-   `getwd()` displays the current working directory\n-   `setwd()` changes the working directory\n    -   On Windows, the path separator is either `/` or `\\\\`\n    -   On Linux/Mac, always `/`\n-   `save()` saves objects as an `.RData` file\n-   `load()` loads objects into the global environment\n-   `list.files()` shows files in the specified directory\n-   `source()` runs an R script\n\n## Extending R with Packages\n\nThere are many packages available on [CRAN](https://cran.r-project.org/) for various applications. These allow for expanding the relatively small core system of R. While R comes with some standard packages, many need to be installed separately.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"AER\")  # Install a previously unavailable package\nlibrary(AER)             # Load the package (makes objects \n                         # in the package visible in the\n                         # global namespace)\ndata(CASchools)          # Example dataset \"CASchools\"\n?ivreg                   # Help for function ivreg\n```\n:::\n\n\n\n-   `search()` shows the search path, i.e., which packages are already loaded:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsearch()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n[4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n[7] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n```\n\n\n:::\n:::\n\n\n\n## Task 1.1\n\nCreate a file `test.R` in your `codes` folder. This file should contain a script that creates the object `x` assigned to `5` and the object `y` assigned to `6`. Before sourcing this `test.R` file using the `source` function, clear your entire workspace. Then, inspect the workspace, compute the product of the two numbers, delete the object `x`, and save the remaining workspace in `.RData` format in the \"RData\" folder.\n\n**Note:** In general, it is wise to avoid frequently changing the working directory. Instead, simply use the `source` function on the explicit code folder.\n\n## Task 1.2\n\nTest R as a calculator: 1. Compute the value of the sine function at `0`. 2. Define `x` as `2` and compute its double third power.\n\n## Task 1.3\n\nFind an R package that provides functions to test linear hypotheses in multiple regression models. Install the package and check the help documentation for one of its functions.\n\n## Task 1.4\n\n1.  Compute the following:\n    -   The cube root of 27.\n    -   The exponential of 3.\n    -   The tangent of π/6.\n2.  Use logical operators to evaluate:\n    -   10 \\<= 15 & 5 \\> 3\n    -   !(7 != 7)\n    -   c(TRUE, FALSE, TRUE) & c(FALSE, TRUE, TRUE)\n\n## Task 1.5\n\n1.  Assign the value 42 to a variable named answer. Then, multiply it by 2 and store the result in a new variable double_answer.\n2.  Create a variable name with the value \"R Programming\". Use the paste() function to combine it with \"is fun!\".\n3.  Swap the values of two variables a = 5 and b = 10 without using a temporary variable.\n\n## Task 1.6\n\n1.  Use the help() function to find information about the lm() function.\n2.  Now, use google to find out how to apply the lm() function.\n3.  Use a LLM of your choice to generate a summary of the lm() function.\n\n# 2. Objects in R\n\n------------------------------------------------------------------------\n\n## Objects in R\n\n-   Everything that exists in R (objects) is either data (a structure) or a function.\n-   Objects each have a class (object orientation).\n\n## First Important Object: Functions\n\nA function is a programming construct that executes a procedure on provided objects and returns a result.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(2.3)\nsin(2)\nclass(log)\nclass(2.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8329091\n[1] 0.9092974\n[1] \"function\"\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n## Functions\n\nThere are functions with and without side effects:\n\n-   Functions **without** side effects take objects as input, perform an operation, and return the result. Example: `log()`\n-   Functions **with** side effects modify objects in the global workspace. Example: `setwd()`, `'<-'()` (assignment is also a function!)\n\n$\\Rightarrow$ When developing functions, side effects should be avoided unless explicitly desired.\n\n## Defining a Function\n\nA function is defined as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Simple function\nproduct1 <- function(x1, x2) x1 * x2\n\n## With preset arguments\nproduct2 <- function(x1 = 1, x2 = 2) x1 * x2\n\n## Curly braces often used for function bodies\nproduct3 <- function(x1 = 1, x2 = 2){\n  x1 * x2\n}\n```\n:::\n\n\n\n-   In the example above, curly braces are not necessary. However, they should be used when a function performs multiple operations.\n\n## Calling a Function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproduct1                      # Display function definition\nproduct1()                    # Calling function without arguments produces an error\nproduct1(x1=2, x2=5)\nproduct1(x1=2, x2=5, y=5)     # Function expects exactly 2 arguments, providing 3 will cause an error\n```\n:::\n\n\n\n**What happens when the function is called?**\n\n`product1(x1 = 1,x2 = 2)`\n\nAt runtime, a new environment is created, containing two variables: `x1` with value `1` and `x2` with value `2`. These are used to compute the product, which is then returned.\n\n------------------------------------------------------------------------\n\nNot all functions require arguments, e.g., `getwd()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf2 <- function() x1 * x2\nx1 <- 2\nx2 <- 3\nf2              # Display function definition\nf2()            # Call function\nf2(x1=2)        # Produces an error, f2 does not accept arguments\nf2(2)\n```\n:::\n\n\n\nSince `f2` has no arguments, `x1` and `x2` are searched in the next higher environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(x1,x2)\nf2()            # Error\n```\n:::\n\n\n\n## More complex Function Example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf4 <- function(x1,x2) {\n    z <- x1 + x2\n    abc <- x1/z\n    return(abc)     # return exits the function\n}\nf4(1,2)             # -> 0.3333333\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\n## Special Argument: The \"Three Dots\" Argument (`...`)\n\nA special argument in R is the \"three dots\" argument (`...`). This allows arguments to be passed flexibly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf5 <- function(e, ...) {\n    log(e, ...)^2\n}\n```\n:::\n\n\n\nAll arguments that `f5` does not explicitly use are passed to `log()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf5(5)\nlog(5, base=10)^2             # log() also has an argument \"base\"\nf5(5, base = 10)              # Passed to log()\nf5(5, base = 10, arg3 = \"a\")  # arg3 is not recognized by log()\n```\n:::\n\n\n\n## Functions That Call Methods\n\nSome functions, such as `print()`, `summary()`, and `plot()`, call methods. These perform different operations depending on the class of the passed object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(cos, -1, 1)    # 'plot' applied to function 'cos'\nx <- 1:5\ny <- 6:10\nplot(x, y)          # 'plot' applied to two vectors 'x' and 'y'\n```\n:::\n\n\n\nR has two (recently three) class systems: S3, S4, and Reference Classes (the latter being closest to object-oriented programming).\n\n## Summary: Functions\n\nAll objects that are not data are functions.\n\nWhat you should now know:\n\n-   Function name, function body, function definition\n\nFor the source code of a function (R is NOT a black box!), Uwe Ligges' [article in R News (p. 43)](https://cran.r-project.org/doc/Rnews/Rnews_2006-4.pdf) is a great reference.\n\n\"When looking at R source code, sometimes calls to one of the following functions show up: `.C()`, `.Call()`, `.Fortran()`, `.External()`, or `.Internal()` and `.Primitive()`. These functions call entry points in compiled code such as shared objects, static libraries, or dynamic link libraries. Therefore, it is necessary to look into the sources of the compiled code if complete understanding of the code is required. ... The first step is to look up the entry point in file `$R HOME/src/main/names.c`, if the calling R function is either `.Primitive()` or `.Internal()`.\"\n\n## Task 2.1\n\n1.  Create a function named `getSquaredSum` that takes two numbers as input, calculates their squared sum, and returns it. Test this function in two ways. Then, set the second function argument to default to `0`.\n\n2.  Create a function in which another function is defined and then called within the function body. Now define the \"inner function\" outside of the \"outer function.\" Which approach do you prefer? Check if everything works and produces the same results!\n\n## Atomic Data Types\n\nAll complex data types (vectors, matrices, lists, etc.) in R are built from atomic data types:\n\n-   `NULL`: the empty set\n-   `logical`: logical values\n-   `integer`: whole numbers\n-   `numeric`: real numbers\n-   `complex`: complex numbers\n-   `character`: letters and strings\n-   For more, see `?typeof`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(2.3)    # numeric\ntypeof(TRUE)   # logical\ntypeof(\"abc\")  # character\ntypeof(log)    # special\n```\n:::\n\n\n\n## Atomic Data Type Functions\n\nFor each atomic data type, there is a function to check if an object belongs to that type, as well as a function to convert (if possible) into the respective type:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(1)       # TRUE\nas.numeric(\"2.3\")   # 2.3\nas.character(2.3)   # \"2.3\"\nis.null(NULL)       # TRUE\n```\n:::\n\n\n\n## Vectors\n\nVectors are the fundamental structure in R and consist of multiple elements of an atomic data type. The function `c()` is used to create vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2.3, 5, 1)\nx <- c(2, 2, 2, x)      # new vector from an existing vector\ny <- c(\"Test\", \"Hello\")\ny <- c(y, x)            # everything converts to 'character', the \"lowest\" data type\nx <- c(x, NA)           # but: NA does not change the type!\n```\n:::\n\n\n\n------------------------------------------------------------------------\n\nOther ways to create vectors:\n\n-   Integer sequences: `1:5`, alternatively: `seq(1,5)`\n-   Arbitrary sequences: `seq(from, to, by)`\n-   Repetitions: `rep()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2:4              # -> 2,3,4\nseq(2,8,2)       # -> 2,4,6,8\nrep(2, 4)        # -> 2,2,2,2\nx <- 1:3\nrep(x, 2)        # -> 1,2,3,1,2,3\nrep(x, each = 2) # -> 1,1,2,2,3,3\n```\n:::\n\n\n\nIndividual elements in vectors can also be named:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(one = 2.4, two = 3, three = 4, last = 2)\n```\n:::\n\n\n\n## Vector Arithmetic\n\nSince R is a vectorized language, all elementary arithmetic operations are vectorized:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,2,3) + c(1,1,1)  # -> 2,3,4\nc(1,2) * c(1,4)      # -> 1,8\n```\n:::\n\n\n\nWarning: If vectors have different lengths, the shorter one is recycled to match the longer one. If the lengths do not align perfectly, a warning is issued:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,2,4) * 2         # 2,4,6 -> second object is converted to c(2,2,2)\nc(1,2,4) * c(2,3)    # 2,6,8 -> with a warning\n```\n:::\n\n\n\n## Vector Indexing\n\nTo access individual elements in a vector, indexing can be used. For example, the fourth element of vector `x` is accessed with `x[4]`. Different indexing methods include:\n\n-   Numeric indexing (also with a vector): `x[c(2,3,7)]` selects the 2nd, 3rd, and 7th elements of `x`.\n-   Logical indexing: `x[c(TRUE, FALSE, TRUE, FALSE, FALSE)]` selects the 1st and 3rd elements of `x` (if `x` has five elements).\n-   Named indexing: Named vectors can be accessed using names: `x[\"one\"]` selects the element named \"one\".\n-   Negative indexing: `x[-1]` selects all elements except the first.\n-   Conditional indexing: `x[ x > 2 ]` selects all elements greater than 2 (if `x` is numeric).\n\n## Useful Vector Functions\n\n-   sort: sort()\n-   revert: rev()\n-   rank: rank()\n-   order (index): order()\n-   exact identical check: identical()\n-   numerical equality: all.equal()\n-   delete duplicaes: unique()\n-   check for duplicates: duplicated()\n-   which elements satisfy condition: which()\n\n## Task 2.2\n\nWrite a function that calculates the sum of two vectors and returns the result as a string in the format:\n\n\"The sum is \\[value\\]\".\n\nTest the function with the following vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxy <- c(1,2,3)\nyx <- c(4,5,6)\n```\n:::\n\n\n\nHint: Check the help for the `paste()` function.\n\n## Matrices\n\nMatrices are created using the function `matrix(data= NA, ncol=1, nrow =1, byrow = FALSE)`. Example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(data = 1:9, ncol = 3, nrow = 3) # Columns are filled first, then rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n\n\n\nIf `data` is not long enough, it is recycled:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(data = 1, ncol = 3, nrow = 3) # Columns are filled first, then rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    1    1\n[3,]    1    1    1\n```\n\n\n:::\n:::\n\n\n\n## Matrices\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(data = c(1,2), ncol = 3, nrow = 3) # Columns are filled first, then rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    2    1    2\n[3,]    1    2    1\n```\n\n\n:::\n:::\n\n\n\nFilling by rows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(data = 1:9, ncol = 3, nrow = 3, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n```\n\n\n:::\n:::\n\n\n\n## Matrix Indexing\n\nIndexing matrices is similar to vector indexing (numeric, logical, by name, etc.), but requires both row and column indices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(data = 1:9, ncol = 3, nrow = 3, byrow = TRUE)\nx[1,3]    # Element in row 1, column 3\nx[1,]     # Returns first row (as a vector)\nx[,2]     # Returns second column (as a vector)\nx[,2, drop = FALSE] # Returns second column (as a 3x1 matrix)\nx[x>2]    # Elements greater than 2 (as a vector)\n```\n:::\n\n\n\n-   `cbind()` and `rbind()` allow matrices to be stacked column-wise or row-wise.\n-   `dim()` returns the number of elements in each dimension.\n\n## Useful Matrix Functions\n\n-   Multiplication: %\\*%\n-   Choleski decomposition: chol()\n-   Return / replace diagonal: diag()\n-   Row / column names: dimnames()\n-   Eigendecomposition: eigen()\n-   Dimensions: dim(), nrow(), ncol()\n-   QR decomposition: qr()\n-   Inverse: solve()\n-   Singular value decomposition: svd()\n-   Transpose: t()\n\n## Arrays\n\nMatrices have two dimensions. A generalization to multiple dimensions is an array, created with the function `array(data, dim)`, where `dim` is a vector specifying the number of elements in each dimension:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narray(1:30, dim = c(3,3,5))\n```\n:::\n\n\n\nThis creates an array with dimensions $3 \\times 3 \\times 5$.\n\n-   Indexing works the same way as for matrices.\n-   Arithmetic operations are applied element-wise:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(1:6, nrow = 2)\nA^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    9   25\n[2,]    4   16   36\n```\n\n\n:::\n:::\n\n\n\n## Task 2.3\n\nFor the matrix `A = Mat_A`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMat_A <- matrix(1:9, ncol = 3)\n```\n:::\n\n\n\nand the vector `b = vec_b`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_b <- 12:14\n```\n:::\n\n\n\nCompute the matrix product $A \\cdot b$ and the element-wise product. Explain the differences.\n\n## Task 2.4\n\nDefine the vector $y = (3,5,2,8,6,4,7)'$ and the matrix $X$, where the first column consists of ones and the second column contains $(4,3,7,1,3,7,5)'$.\n\n1.  Extract the third observation from `X` and `y`.\n2.  Compute $X'X$, $X'y$, $(X'X)^{-1}$, and the OLS estimator of the linear regression model. **Hint:** The formula for the OLS estimator is $\\hat{\\beta} = (X'X)^{-1}X'y$.\n3.  Compute the standard errors of the coefficients under standard assumptions.\n4.  Create a function that takes `y` and `X` and returns a matrix containing the OLS estimates and their standard errors as columns.\n\n## Task 2.5\n\nAdd the following matrix to your R environment $$A = \\begin{pmatrix}\n1.0 &  0.5\\\\\n0.5 & 1.0\n\\end{pmatrix}.$$ Calculate the eigendecomposition $V\\cdot \\Lambda\\cdot V^{-1}$ of $A$, where $\\Lambda$ is a diagonal matrix holding the eigenvalues, and $V$ is a matrix of eigenvectors. Check whether the above product equals $A$.\n\n## Task 2.6\n\n1.  When optimization involves a non-diagonal covariance matrix $Q$, one needs to ensure $Q$ is symmetric p.s.d., which limits the parameter space of the optimization problem. Write a bijective function $Q = f(\\theta)$ that maps a three-dimensional parameter vector $\\theta \\in \\mathbb{R}^3$ to the $2 \\times 2$ covarinace matrix $Q$, $f: \\theta \\rightarrow Q$, ensuring $Q$ is symmetric p.s.d.\n\n2.  Write the inverse function $f^{-1}: Q \\rightarrow \\theta$\n\n3.  Use a LLM to solve the two tasks and check with your solution. What prompt do you use? Do you get the same results?\n\n## Lists\n\nVectors, matrices, and arrays require all elements to be of the same data type. Lists, however, are more general as they allow arbitrary combinations of data types. A list is created using the `list()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1 <- list(\n  a = 1:3,\n  A = matrix(1:9,3,3),\n  w = \"Hello!\"        # Elements can have names AND be of any type!\n)\n```\n:::\n\n\n\nLists can also contain other lists:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2 <- list(\n  a = 1:3,\n  l1 = L1 # List within a list\n)\n```\n:::\n\n\n\n## Lists\n\nLists are indexed using double square brackets (numeric, logical, by name):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1[[1]]    # 1,2,3     -> Vector\nL1[1]      # list(1:3) -> Still a list (sublist of L1)\nL1[[\"w\"]]  # \"Hello!\"\n```\n:::\n\n\n\nNamed lists can also be accessed using the `$` operator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1$w       # \"Hello!\"\n```\n:::\n\n\n\n## Task 2.7\n\n-   Create your own list with three different data types and names.\n-   Use both numeric indexing and name-based indexing.\n-   Apply the `str()` function to your list.\n-   Create a list of lists of lists.\n\n## Dataframes\n\nDataframes are lists whose elements are vectors of the same length but not necessarily of the same data type. Typically, datasets in R are stored in dataframes.\n\nDataframes are created using `data.frame()` and can be indexed both like matrices and like lists.\n\nExamples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPlayers <- data.frame(\n  FirstName = c(\"Joren\",\"Ozgur\",\"Bryan\",\"Camil\"),\n  LastName =  c(\"Op de Beeck\",\"Aktas\",\"Smeets\",\"Mmaee\"),\n  Position = c(\"Goalkeeper\",\"Defender\",\"Midfielder\",\"Forward\"),\n  Age = c(19,28,32,20),\n  Number = c(23,3,5,7),\n  stringsAsFactors = FALSE      # Names should be read as \"character\"\n                                # and not as \"factor\"\n)\n```\n:::\n\n\n\n## Dataframes\n\nIndexing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(Players)       # Variable names\nPlayers$FirstName    # Indexing like a list ($)\nPlayers[,1]          # Numeric indexing like a matrix\nPlayers[,\"FirstName\"] # Name-based indexing\n\nPlayers[Players$LastName==\"Smeets\" , ] # Logical indexing\n```\n:::\n\n\n\nTo add variables to the dataset:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPlayers$Gender <- c(\"m\", \"m\", \"m\", \"m\")\n```\n:::\n\n\n\n## Dataframes\n\nOften, you want to select specific observations from a dataset. The `subset()` function is useful for this, along with the `%in%` operator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(Players, FirstName %in% c(\"Joren\", \"Bryan\"))\n```\n:::\n\n\n\nLater, we will explore functions from the `dplyr` package, which provide more flexibility for selections.\n\nOther useful functions for `data.frames`:\n\n-   `summary()`: Outputs summary statistics for each variable\n-   `head()`: Displays the first few rows\n-   `tail()`: Displays the last few rows\n-   `attach()`: Makes dataset variables visible in the global workspace\n-   `split()`: Splits the dataset into subsets\n-   `merge()`: Merges two datasets with different variables\n\n## Task 2.8\n\nUse the `data.frame` \"Players\" that was just created and perform the following actions:\n\n1.  Rename the column \"FirstName\" to \"prename\".\n2.  Access age in two different ways (compare the similarity of data.frame, matrix, and list indexing).\n3.  Perform a logical indexing to select all people with number greater or equal to six.\n4.  Add a new observation (row) with arbitrary data (e.g., yourself).\n5.  Add a new characteristic (column) to the dataset, e.g. the birthdate or the number of yellow cards.\n6.  Select all individuals younger than 30 years who are not goalkeepers.\n\n## Additional Objects (Factor Variables, Ordered Categorical, Time Series, Date/Time Variables)\n\nThese special objects are not atomic data types, but they are useful in many applications.\n\n## Factor Variables\n\nInformation about groups (categorical features) is often required. Examples include:\n\n-   Gender\n-   Car brand\n-   Day of the week\n-   Federal state\n\nFor this type of information, R provides factor variables, which are created using `factor()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rep(c(1,2), 4)\nfactor(x, labels=c(\"female\", \"male\"))\nZ <- c(\"Yes\",\"Yes\",\"No\",\"Yes\",\"Maybe\",\"No\",\"Maybe\",\"Yes\",\"Yes\",\"No\")\nfactor(Z)\n```\n:::\n\n\n\n## Why Use Factors?\n\n-   Less memory usage\n-   Usable in plots and regressions (e.g., coplots later)\n-   `summary()`, `plot()` provide useful functionality:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- sample(x=1:2, size=100, replace = TRUE)\nx <- factor(x, labels = c(\"male\", \"female\"))\nplot(x)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list45-1.png){width=480}\n:::\n\n```{.r .cell-code}\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  male female \n    57     43 \n```\n\n\n:::\n:::\n\n\n\n## Ordered Categories\n\nCategorical data can sometimes have a meaningful order.\n\n**Example:**\n\nSurveys often include questions like:\n\n*\"AI is very helpful, but only if we understand what we want and express it clearly!\"*\n\nwith response options:\n\n-   `strongly agree`\n-   `partially agree`\n-   `neutral`\n-   `somewhat disagree`\n-   `strongly disagree`\n\nIn such cases, ordering is useful - also for statistical analysis.\n\n## Ordered Categories\n\nOrdered factor variables are created using the `ordered()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nord <- c(\"very good\",\"medium\",\"good\",\"bad\",\"good\",\"bad\",\"medium\",\"very good\",\"good\")\nclass(ord)     # character\n\nOF <- ordered(ord, levels=c(\"very bad\",\"bad\",\"medium\",\"good\",\"very good\"))\nclass(OF)      # ordered, factor\n```\n:::\n\n\n\n## Task 2.9\n\nCreate a factor with the levels `\"Flanders\", \"Wallonia\", \"Brussels\"`. Also, create an ordered factor sorted in alphabetical order.\n\n## Date and Time Information\n\nSometimes, timestamps and/or date information are needed. R provides dedicated data structures for this purpose:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.time()            # Current system time, e.g., \"2019-11-08 19:03:43 CET\"\nclass(Sys.time())     # \"POSIXct\" \"POSIXt\"\n?POSIXct              # Help on DateTimeClasses\n```\n:::\n\n\n\nThe `POSIXct` class is a data structure that stores a timestamp as the number of seconds since January 1, 1970, 00:00:00 UTC:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- as.POSIXct(\"2019-11-24 10:12:05\", tz = \"UTC\")  # Specify the 'timezone'\nas.numeric(x)                                       # -> 1574590325\n```\n:::\n\n\n\n## Date and Time Formats\n\nPOSIX timestamps are a widely used convention for representing time in computers.\n\nR provides multiple formatting options for `POSIXct`/`POSIXlt` through the `format()` function (see also the `strptime()` function and the article on [R-Bloggers](https://www.r-bloggers.com/date-formats-in-r/)).\n\nSome format specifiers:\n\n-   `%m`: Month as a decimal number (01-12)\n-   `%y`: Year without century (00 - 99)\n-   `%Y`: Year with century, e.g., 1987\n-   `%H`: Hour as a decimal number\n\nExample:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- as.POSIXct(\"2019-11-24 10:12:05\", tz = \"UTC\")\nformat(x, format = \"%Y-%m: %H Uhr\")     # \"2019-11: 10 Uhr\"\n```\n:::\n\n\n\n## Date Information\n\nOften, only the date (without the time) is needed. For this, R provides the `Date` class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- as.Date(\"2019-11-24\")  # Standard format: %Y-%m-%d\nclass(x)                     # \"Date\"\nx <- as.Date(\"24.11.2019\", format = \"%d.%m.%Y\") # Different format must be specified\nas.numeric(x)                # 18224 (Number of days since 1/1/1970)\n```\n:::\n\n\n\nWith the `Date` and `POSIXct` classes, calculations can be performed:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- as.Date(\"2019-11-24\") - as.Date(\"2019-11-14\")) # -> Time difference of 10 days\nclass(x)                                             # \"difftime\"\n```\n:::\n\n\n\n## Task 2.10\n\nOn November 3, 2020, the U.S. presidential election took place.\n\n1.  Read this date into R.\n\n2.  Format it in R as:\n\n    -   \"20201103\"\n    -   \"2020-Nov\"\n    -   \"Calendar week: 45\"\n\n## Task 2.11\\*\n\nOn what day last year did the transition from daylight saving time to standard time occur?\\\n**Hint**: It is sufficient to show that this day had 25 hours.\n\n## Time Series Data\n\nThere are several possible classes for time series in R, e.g., `ts` (from the `stats` package) and `zoo` (provided by the `zoo` package):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuemp <- ts( data =  c( 4284691,4247561,4124836,3976555,\n                      3812335,3687597,3715509,3705949,\n                      3543866,3434067,3378747,3406389,\n                      3659316,3617418,3507383,3413881),\n           start = c(2007,1),\n           frequency = 12)   # Starts in January 2007, monthly time series\nclass(uemp)                   # \"ts\"\n```\n:::\n\n\n\n`ts` objects can only represent regular time series. This can sometimes be inconvenient (e.g., trading days in the stock market). For irregular time series, `zoo` can be used:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na      <- 1:10\na.Date <- seq(from = as.Date(\"2010-01-01\"), to = as.Date(\"2020-01-01\"), by = \"years\")[-3]\na.zoo  <- zoo(x = a, order.by = a.Date)\n```\n:::\n\n\n\n## Task 2.12\n\nGenerate a variable `Birthdate` of class date that holds your date of birth. Then, calculate how many days have passed since you have been born.\n\n## Reading Data\n\nThere are various ways to read data into R, depending on the format in which the data is stored:\n\n-   If data is available as an R image (`.RData`), objects within it can be easily loaded into the workspace using `load()`.\n-   Structured text files are often used for datasets. For example, the dataset `Players` in CSV format (with `,` as a separator) looks like this:\n\n\n\n::: {.cell}\n\n```{.c .cell-code}\n\"\",\"FirstName\",\"LastName\",\"Position\",\"Age\",\"Number\"\n\"1\",\"Joren\",\"Op de Beeck\",\"Goalkeeper\",19,23\n\"2\",\"Ozgur\",\"Aktas\",\"Defender\",28,3\n\"3\",\"Bryan\",\"Smeets\",\"Midfielder\",32,5\n\"4\",\"Camil\",\"Mmaee\",\"Forward\",20,7\n```\n:::\n\n\n\nFunctions to read structured text files include `read.table()`, `read.csv()`, `read.csv2()`, `read.delim()`, and `read.delim2()`, each with different default settings.\n\n## Reading Data\n\n-   `xls`/`xlsx` files: R previously had difficulties handling Excel files, but now the `readxl` package provides functions `read_xls()` and `read_xlsx()`.\n-   Data from other statistical software (Stata, SPSS, Eviews, SAS, etc.) can be read using the `foreign` and `haven` packages.\n\nExamples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_pers <- read.table(\"players.csv\",\n                        header = TRUE, ## Variable names in the first row\n                        sep = \";\"      ## Column separator \" ; \"\n                        )\n```\n:::\n\n\n\n## Reading Data\n\nMore examples (first, download a zip folder with sample files):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Download sample files\ncurl::curl_download(url =\"https://drive.google.com/uc?export=download&id=1JMsHywhBeDAzNnqD0bHIAWJq0eB79wBr\",\n                    destfile = \"example_data.zip\")\n## Unzip the files\nres <- unzip(\"example_data.zip\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"readxl\", \"haven\") ## Install packages if not available\nlibrary(readxl)\n\nexcel_data <- read_xls(\"Africa.xls\", skip = 7,\n                       col_names = c(\"country\",\"pop\", \"larea\",\"pop_dens\",\n                                     \"gdpppp\", \"gdppcppp\",\"gdpgrwth\"))\n\ndax <- read.csv(\"dax.csv\") ## Default values for sep, dec, and header already match!\nschools_treat <- haven::read_dta(\"TreatmentSchools.dta\") ## Specify namespace using \"::\"\n```\n:::\n\n\n\n## Task 2.13\n\nRead in unemployment data (from 2013) in Germany (number and rate) at the district level into R. Download the corresponding [data set](https://www.dropbox.com/scl/fi/wu0epccdt4g3lqyv2hspb/alq.csv?rlkey=lbermmc9d3d8zfiz6wbjyepit&e=1&st=0351bm1j&dl=1).\n\nUse the `read.table` function and import the dataset as `data_uemp`. After reading in the data, perform the following steps:\n\n-   Print a summary (check if all variables are correct).\n-   If the column headers were not read correctly, assign the following names: `DistrictKey`, `District`, `Abs_uemp`, `Rate_uemp`\n\n## Task 2.13 (Continuation)\n\n-   Calculate the total workforce and overall unemployment rate.\n\n-   Truncating `DistrictKey` after dividing by 1000 assigns each number from 1 to 16 to a federal state. The order is:\n\n    `\"Schleswig-Holstein\", \"Hamburg\", \"Lower Saxony\", \"Bremen\", \"NRW\", \"Hessen\", \"Rhineland-Palatinate\", \"BW\", \"Bavaria\", \"Saarland\", \"Berlin\", \"Brandenburg\", \"Mecklenburg-Vorpommern\", \"Saxony\", \"Saxony-Anhalt\", \"Thuringia\"`\n\n    Add a new column indicating the federal state for each observation. **Hint**: The function `trunc()` may be useful.\n\n-   Use the `order()` function to display the 30 districts with the highest unemployment rates.\n\n-   Save the dataset as `uemp_regions.txt` and the complete `data.frame` (including federal states) as `uemp.RData`. (The latter, including federal states, will be needed later.)\n\n## More Input/Output\n\n-   Most data can be saved to disk just as they are read in using `write.csv()`, `write.table()`, `haven::write_dta()`, etc.\n\n-   More fundamental methods to read/write data: `readLines()`/`writeLines()`, `scan()`/`write()`.\n\n-   Database connections via the `odbc` package.\n\n-   Reading from the clipboard after copying data from the *People* dataset:\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    players <- read.table(file(description = \"clipboard\"), sep = \";\")\n    ```\n    :::\n\n\n\n-   Network resources via `url()`, compressed files with `unz()`, etc.\n\nSee also `?connections()`.\n\n# 3. Graphics\n\n## R Base Graphics\n\n-   This chapter covers graphical functions from the `graphics` package.\n-   Other graphics packages include `ggplot2` (see [book](https://ggplot2-book.org/) by Hadley Wickham), `plotly`, `Rgnuplot`,...\n\nTo create plots with R's standard `graphics` package, there are *high-level* and *low-level* plotting functions. \n\n- *High-level* functions generate a new graphic (and open a *device*). \n- *Low-level* functions add elements to an existing graphic.\n\n---\n\nAvailable *devices* include: \n\n- `windows()`/`x11()`/`quartz()`: Screen graphics (Windows, Unix, Mac), (default). \n- `pdf()`: Adobe PDF (easily integrated into LaTeX). \n- `svg()`: Scalable Vector Graphics (commonly used on websites). \n- `png()`, `jpeg()`, `tiff()`, `bmp()`: Various bitmap formats.\n\n\n\n\n---\n\n\nCreating a graphic:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npdf(\"myPlot.pdf\")                   ## Open plot device\nplot(y = rnorm(100), x = 1:100)     ## Create graphic with high-level function plot()\ndev.off()                           ## Close plot device\n```\n:::\n\n\n\n`plot()` is a function that calls different methods for different objects:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction (x, y, ...)\nUseMethod(\"plot\")\n<bytecode: 0x55ef0a3b5ec8>\n<environment: namespace:graphics>\n```\n:::\n\n\n\nThese methods correspond to the available high-level plot functions.\n\n## Types of Plots (High-Level Plots)\n\n-   `barplot()`: Bar chart\n-   `pie()`: Pie chart (`plotrix` package includes `pie3d`)\n-   `boxplot()`: Box plot\n-   `contour()`: Ideal for contour maps, i.e., f: R² -\\> R; `filled.contour()` for colored contour maps\n-   `coplot()`: Conditioning plot\n-   `curve()`: Line plot, allows function input via `curve(f(x))`\n-   `dotchart()`: Useful for many factors with one level\n-   `hist()`: Histogram\n-   `mosaicplot()`: Mosaic plot; useful for compositions over time\n\n---\n\n-   `pairs()`: Useful for correlation analysis\n-   `image()`: For drawing images\n-   `persp()`: 3D graph drawing, including coordinate axis selection\n-   `scatterplot3d()`: Same as above\n-   `qqplot()`: Quantile-Quantile plot\n\n------------------------------------------------------------------------\n\nExamples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(url(\"https://www.dropbox.com/scl/fi/9u8h45ajulcw3qm4ucrn9/CPS1985.RData?rlkey=4f81urvkwjhihyvn88g15o92w&st=nmwi22od&dl=1\"))\nclass(CPS1985)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(CPS1985)             ## plot on data.frame calls pairs()\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list62-1.png){width=864}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nExamples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(CPS1985$wage)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(CPS1985$wage)       ## plot on numeric calls plot.default()\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list63-1.png){width=864}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nExamples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(CPS1985$occupation)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(CPS1985$occupation)       ## plot on factor calls barplot()\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list64-1.png){width=864}\n:::\n:::\n\n\n\n## A Continuous Variable\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))\nhist(CPS1985$wage, breaks = 20)\nplot(density(CPS1985$wage))\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list65-1.png){width=864}\n:::\n:::\n\n\n\n## A Discrete Variable\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(CPS1985$occupation)        ## Generates barplot(table(CPS1985$occupation))\npie(table(CPS1985$occupation))  ## Same information, but not necessarily recommended\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list66-1.png){width=864}\n:::\n:::\n\n\n\n## Two Continuous Variables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Scatterplot as a starting point for most analyses:\nplot(x = CPS1985$education, y = CPS1985$wage)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list67-1.png){width=864}\n:::\n:::\n\n\n\n## Two Discrete Variables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Mosaic plot as a starting point for most analyses:\nplot(gender ~ occupation, data = CPS1985)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list68-1.png){width=864}\n:::\n:::\n\n\n\n## Continuous Variable Dependent on a Discrete Variable\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(wage ~ occupation, data = CPS1985)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list69-1.png){width=864}\n:::\n:::\n\n\n\n## Three or More Variables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Sequentially\npar(mfrow = c(1,2))\nplot(wage ~ education + occupation, data = CPS1985)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list70-1.png){width=864}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## In one plot\ncoplot(wage ~ education | occupation, data = CPS1985)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list71-1.png){width=864}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Four variables in one plot\ncoplot(wage ~ education | occupation + gender, data = CPS1985)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list72-1.png){width=864}\n:::\n:::\n\n\n\n## Customizing Graphics\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nhist(CPS1985$education, breaks = 3)  ## Coarsely detailed histogram\nhist(CPS1985$education, breaks = 16) ## More detailed histogram\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list73-1.png){width=864}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))\nplot(CPS1985$wage, type = \"p\") ## Points\nplot(CPS1985$wage, type = \"l\") ## Lines\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list74-1.png){width=960}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Title and axis labels\npar(mfrow = c(1,2))\nwith(CPS1985, {\n  plot(x = age, y = wage,\n     main = \"Scatterplot of Age and Hourly Wage\")\n  plot(age, wage,\n     xlab = \"Age in Years\", ylab = \"Hourly Wage\",\n     main = \"Scatterplot of Age and Hourly Wage\")\n})\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list75-1.png){width=960}\n:::\n:::\n\n\n\n## Fine-Tuning\n\nNot everything can be adjusted via optional arguments in high-level functions; in such cases, `par()` is often used: \n<div style=\"display: flex; gap: 2em;\">\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(bg = \"yellow\")\nwith(CPS1985,\n     plot(age)\n)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list76-1.png){width=480}\n:::\n:::\n\n\n\n</div> <div style=\"flex: 1;\"> \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(bg = \"transparent\", cex=0.5)\nwith(CPS1985,\n     plot(age)\n)\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list77-1.png){width=480}\n:::\n:::\n\n\n\n</div> </div>\n\n\n---\n\n**Overview**: Frequently used arguments in graphic functions. See `?par` for all graphical options\n\n\n - `axes`: Axis specification\n - `bg`: Background color\n - `cex`: Factor for scaling relative to the default\n - `col`: Plot color\n - `log`: `xlog` and `ylog` for logarithmic scales\n - `lty`, `lwd`: Line type and thickness\n - `mai`: 4-vector specifying margins (bottom, left, top, right)\n - `main`, `sub`: Title, subtitle\n - `mar`: Margin\n  \n---\n\n - `mfcol`, `mfrow`: Multiple plots in one graphics window (column-wise/row-wise)\n - `pch`: Point character (1-16)\n - `usr`: The extreme points for a plot\n - `xlab`, `ylab`: x and y axis labels\n - `xlim`, `ylim`: x and y axis limits\n\n\n\n## Low-Level Graphic Functions\n\n - `lines`: Draw lines\n - `abline`: Quickly add horizontal, vertical lines, and lines using equation $y = bx + a$\n - `points`: Add points\n - `arrows`: Add arrows\n - `polygon`: Draw arbitrary polygons\n - `segments`: Draw unfilled polygons\n - `axis`: Customize axes\n - `grid`: Add a grid\n\n---\n\n - `rug`: \"Density carpet\"\n - `title`: Add a title\n - `legend`: Add a legend\n - `text`: Add text at $(x,y)$ coordinates\n - `mtext`: Add text with positional specification like `side=1,...,4`\n\n---\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattach(CPS1985) ## see ?attach\nplot(x = education, y = wage, #<<\n     pch = 16, axes = FALSE)  #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list78a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n---\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattach(CPS1985)\nplot(x = education, y = wage,\n     pch = 16, axes = FALSE)\n\n# Add axes\nticks <- seq(-100, 100, 0.5) #<<\naxis(side = 1, at = ticks,   #<<\n     labels = paste(ticks,\"y\"))\n\naxis(side = 2, at = \n        seq(-100,100, 0.5))#<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list79a-1.png){width=960}\n:::\n:::\n\n\n</div> </div>\n\n\n---\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattach(CPS1985)\nplot(x = education, y = wage,\n     pch = 16, axes = FALSE)\n\n# Add axes\nticks <- seq(-100, 100, 0.5)\naxis(side = 1, at = ticks,\n     labels = paste(ticks,\"y\"))\n\naxis(side = 2, at = \n        seq(-100,100, 0.5))\n\n# Add tick marks\nrug(wage, side = 2) #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list80a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n---\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattach(CPS1985)\nplot(x = education, y = wage,\n     pch = 30, axes = FALSE)\n\n# Add axes\nticks <- seq(-100, 100, 0.5)\naxis(side = 1, at = ticks,\n     labels = paste(ticks,\"y\"))\n\naxis(side = 2, at = \n        seq(-100,100, 0.5))\n\n# Add tick marks \nrug(wage, side = 2)\n\n# Add regression line \nabline(a = -0.7460, b=0.7505, \n        col=\"blue\") #<<\nabline(h = mean(wage), lty=2, \n    col = \"red\", lwd = 8) #<<\nabline(v = mean(education), lty=3, \n    col = \"orange\", lwd = 4) #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list81a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n---\n\n\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = education, y = wage, # <<<<<<<<\n     pch = 16)\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list82a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n\n---\n\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = education, y = wage, # <<<<<<<<\n     pch = 16)\nlines(x = c(2, 7, 10),        #<<\n      y = c(20, 30, 25),      #<<\n      col=\"darkgreen\", lwd = 3) #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list83a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n\n---\n\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = education, y = wage, # <<<<<<<<\n     pch = 16)\nlines(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkgreen\", lwd = 3)\npoints(x = c(2, 7, 10),        #<<\n      y = c(20, 30, 25),      #<<\n      col=\"darkred\", pch = 19) #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list84a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n\n---\n\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = education, y = wage, # <<<<<<<<\n     pch = 16)\nlines(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkgreen\", lwd = 3)\npoints(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkred\", pch = 19)\npolygon(x = c(3, 3, 10, 8), #<<\n        y = c(10,20,20,10), #<<\n        col=\"lightgreen\") #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list85a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n\n---\n\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = education, y = wage, # <<<<<<<<\n     pch = 16)\nlines(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkgreen\", lwd = 3)\npoints(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkred\", pch = 19)\npolygon(x = c(3, 3, 10, 8),\n        y = c(10,20,20,10),\n        col=\"lightgreen\")\narrows(x0 = 10, y0 = 40, x1 = 13.8, #<<\n       y1 = 44.2, lwd = 5, #<<\n       col = \"darkblue\")   #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list86a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n\n---\n\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = education, y = wage, # <<<<<<<<\n     pch = 16)\nlines(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkgreen\", lwd = 3)\npoints(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkred\", pch = 19)\npolygon(x = c(3, 3, 10, 8),\n        y = c(10,20,20,10),\n        col=\"lightgreen\")\narrows(x0 = 10, y0 = 40, x1 = 13.8,\n       y1 = 44.2, lwd = 5,\n       col = \"darkblue\")\ntitle(\"Wage versus Education\") #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list87a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n---\n\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = education, y = wage, # <<<<<<<<\n     pch = 16)\nlines(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkgreen\", lwd = 3)\npoints(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkred\", pch = 19)\npolygon(x = c(3, 3, 10, 8),\n        y = c(10,20,20,10),\n        col=\"lightgreen\")\narrows(x0 = 10, y0 = 40, x1 = 13.8,\n       y1 = 44.2, lwd = 5,\n       col = \"darkblue\")\ntitle(\"Wage versus Education\") #<<\ntext(x = 11, y = 30, \n    \"Text in Plot\") #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list88a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n\n---\n\n\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = education, y = wage,# <<<<<<<<\n     pch = 16)\nlines(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkgreen\", lwd = 3)\npoints(x = c(2, 7, 10),\n      y = c(20, 30, 25),\n      col=\"darkred\", pch = 19)\npolygon(x = c(3, 3, 10, 8),\n        y = c(10,20,20,10),\n        col=\"lightgreen\")\narrows(x0 = 10, y0 = 40, x1 = 13.8,\n       y1 = 44.2, lwd = 5,\n       col = \"darkblue\")\ntitle(\"Wage versus Education\") #<<\ntext(x = 11, y = 30, \"Text in Plot\")\nlegend(x=\"topright\", #<<\n  legend = c(\"Data point\",\"Line\"), #<<\n  lty = c(NA, 1), \n  pch = c(19, NA),   #<<\n  lwd = c(1, 3), \n  col = c(1, \"darkgreen\"))  #<<\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/list89a-1.png){width=960}\n:::\n:::\n\n\n\n</div> </div>\n\n\n\n\n## Task 3.1\n\nDraw a plot of the function \\( f(x) = e^x + 2 \\) in the range from -2 to +2, with the line color set to green.  \nCreate a legend in the upper left corner with the entry \\( e^x + 2 \\) and the corresponding line.\n\n**Hint**: To include mathematical labels in a legend, you need to use  \n\"mathematical annotations,\" which can be found [here](http://stuff.mit.edu/afs/sipb/project/r-project/arch/i386_rhel3/lib/R/library/graphics/html/plotmath.html).  \nWith `paste()` and `expression()`, this should be straightforward.\n\n\n\n## Task 3.2  \n\nCreate a scatter plot of `wage` against `education` (from the `CPS1985` dataset),  \nwhere women appear as red points and men as blue points.  \nAdd a legend to illustrate this distinction.\n\n\n\n## Task 3.3  \n\nTry to draw a white, five-pointed star on a red background (e.g., using `polygon()`).  \nSave this as a `.pdf` file in the \"graphs\" folder.\n\n## Task 3.4  \n\nSee whether a LLM improves your graph: Write a promt for a LLM of choice to create a scatter plot of `wage` against `education`. Again, distinguish between men and women. Come up with further characteristics you could add, and see if the AI model produces a satisfactory graph. \n\n\n\n\n\n\n# 4. Data Analysis\n\n\n\n---\n\n\n## Consistent Work with Data: tidyverse\n\nIn this chapter, we will (superficially) cover the package [dplyr](https://dplyr.tidyverse.org/). This package is part of the [tidyverse](https://www.tidyverse.org/), a collection of R packages designed to provide a consistent approach to working with data. The following packages belong to the [tidyverse](https://www.tidyverse.org/):\n\n - [dplyr](https://dplyr.tidyverse.org/): \"Grammar of Data Manipulation\"\n\n - [ggplot2](https://ggplot2.tidyverse.org/): \"Grammar of Graphics\"\n\n - [readr](https://readr.tidyverse.org/): \"Fast and friendly way to read rectangular data\"\n\n - [tibble](https://tibble.tidyverse.org/): \"A tibble, or tbl_df, is a modern reimagining of the data.frame\"\n\n - [tidyr](https://tidyr.tidyverse.org/): \"Create tidy data. Tidy data is data where:\n      1. Every column is a variable.\n      2. Every row is an observation.\n      3. Every cell is a single value.\"\n\n - [purrr](https://purrr.tidyverse.org/): \"Enhance R’s functional programming toolkit\"\n\n---\n\n\n\nAn important component of working with data and `dplyr` is the pipe operator `%>%`, included in the `magrittr` package. The goal of this operator (also found in many other languages) is to make function composition more readable in code.\n\nExample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nf <- function(x) x + 10\ng <- function(x) x * 2\n\na <- 2\nf(g(a))         # 2*a + 10 -> 14\n\n## Same result using the pipe operator\na %>% g() %>% f()\n\n## Parentheses for function calls can be omitted,\n## but for readability, it is helpful to keep them\na %>% g %>% f\n```\n:::\n\n\n\n---\n\nMore examples\n<div style=\"display: flex; gap: 2em;\">\n\n<div style=\"flex: 1;\">\n\n**dplyr** with `%>%`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPeople %>%\n  dplyr::select(Age) %>%\n  summary()\n\n\nCPS1985 %>%\n  filter(age > 25) %>%\n  group_by(gender) %>%\n  summarise(mwage = mean(wage))\n```\n:::\n\n\n\n</div> <div style=\"flex: 1;\">\n\n**Standard R**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(\n  subset(People, select = Age)\n  )\n\ndatatemp <- subset(CPS1985, age > 25)\ntapply(X = datatemp$wage,\n      INDEX = datatemp$gender,\n      FUN = mean)\n```\n:::\n\n\n\n </div> </div>\n\n\nIn the second example, you can already see that the pipe operator often eliminates the need for unnecessary assignments.\n\n\n## `dplyr`\n\nThe key functions of `dplyr` are:\n\n- [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.html): Add new variables to a dataset\n\n- [`select()`](https://dplyr.tidyverse.org/reference/select.html): Select variables (columns)\n\n- [`filter()`](https://dplyr.tidyverse.org/reference/filter.html): Select observations (rows)\n\n- [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.html): Sort observations\n\n- [`summarise()`](https://dplyr.tidyverse.org/reference/summarise.html): Reduce variable values of multiple observations to a single value\n\n- [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.html): Apply subsequent operations to groups\n\n- `join()`: Merge two datasets\n\nThese functions often have variants and additional helper functions that assist with variable selection.\n\n---\n\nDatasets that are *tidy* should have each observation as a row and each variable as a column (`long` format). However, datasets are often found in `wide` format.\n\nA way to convert `wide` to `long` is the `pivot_longer()` function from `tidyr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr) ## version 1.0.0\ndata_wide <- data.frame(id = c(1,2,3,4),\n                        wage90 = c(12,13,14,11),\n                        wage95 = c(14,16,13,18))\n\ndata_long <- data_wide %>%\n  pivot_longer(cols = starts_with(\"wage\"), # Select columns #<<\n               names_to = \"year\",          # New column name #<<\n               values_to = \"wage\")         # New column for values #<<\n\nclass(data_long) # tbl_df, tbl, data.frame\n```\n:::\n\n\n\n\n## A Single Variable\n\nMeasures of central tendency:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Continuous variable\nCPS1985 %>%\n  summarise(mean_wage = mean(wage),\n            sd_wage = sd(wage),\n            med_wage = median(wage),\n            min_wage = min(wage),\n            q1_wage = quantile(wage,0.25))\n\n## For simple cases, this also works:\nsummary(CPS1985$wage)\n\n## Discrete variable\ntable(CPS1985$occupation)\n```\n:::\n\n\n\n\n## Graphical Representation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Lambda expression and dot placeholder\nCPS1985 %>%\n  mutate(lwage = log(wage)) %>%\n  select(lwage) %>% {\n    lwage <- .[,1]     # '.' represents the value from the left \n                       # side before the last pipe operator\n    hist(lwage)        # Equivalent to CPS1985 %>% select(wage)\n  }\n```\n:::\n\n\n\n\n## Multiple Variables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Multiple continuous variables\nCPS1985 %>%\n  select(wage, education, age) %>% {\n    pairs(.)\n    cor(.)\n  }\n\n## Discrete variables (frequency tables)\nCPS1985 %>%\n  group_by(gender, sector) %>%\n  summarise(n = n())\n\n## Alternative:\nwith(CPS1985,\n     ftable(gender, sector)\n)\n## Or also:\nxtabs(~gender + sector, data = CPS1985)\n```\n:::\n\n\n\n\n## Task 4.1\n\nUse the dataset `CPS1985` from the `AER` package.\n\n1. Add the variable `logW` (log-transformed wages) to the dataset using `mutate()` and the pipe operator.\n\n2. Compute, grouped by `gender` and `occupation`, the mean log wages and their standard deviation.\n\n3. Select the observation with the highest wage for both men and women.\n\n4. Add a variable `lowest_wage_in_occ` to the `CPS1985` dataset, which remains constant within each `occupation` group and corresponds to the lowest wage in that respective group.\n\n5. Sort the dataset within gender groups by wages.\n\n---\n\n## Task 4.2\n\nEnhance the histogram of (log) wages within the lambda expression on [Slide 124](#124) as follows:\n\n1. Add the density function of a normally distributed random variable with the same mean and variance as the log wages.\n\n2. Draw the mean as a dashed line.\n\n3. Use a polygon to shade the area under the density function up to the 25% quantile.\n\n\n## Task 4.3\nThe code on the next slide collects climate data for Dutch cities. Use `dplyr` to \n\n1. find the warmest and coldest day in Maastricht\n2. find the city with the highest average temperature in 2023 and the one with the lowest average temperature\n3. count the number of rainy days (`I_RAIN_DRIZZLE`) and identify the city with the highest and lowest number of rainy days. \n4. identify the cities with the highest and lowest average rainfall (`PRCP`, hint: use na.rm = TRUE to get rid of the NA values)\n5. Modify the code to get a time series for Maastricht only. Plot minimum, maximum and average temperature across time.\n\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install if needed\ninstall.packages(c(\"dplyr\", \"lubridate\", \"GSODR\"))\n\n# Load libraries\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(GSODR)\n# list of Dutch cities \ncities <- data.frame(\n  city = c(\"Amsterdam\", \"Rotterdam\", \"The Hague\", \"Utrecht\", \"Eindhoven\", \"Tilburg\", \"Groningen\", \"Almere\", \"Breda\", \"Nijmegen\", \"Enschede\", \"Haarlem\", \"Arnhem\", \"Zaanstad\", \"Maastricht\", \"Apeldoorn\"),\n  lat = c(52.37, 51.92, 52.08, 52.09, 51.44, 51.56, 53.22, 52.37, 51.59, 51.84, 52.22, 52.39, 51.98, 52.45, 50.85, 52.21),\n  lon = c(4.89, 4.48, 4.30, 5.11, 5.48, 5.09, 6.57, 5.22, 4.78, 5.85, 6.89, 4.64, 5.92, 4.81, 5.69, 5.97)\n)\n\n# Find closest weather stations\ncities$stations <- sapply(1:NROW(cities), function(j){\n    nearest_stations(cities$lat[j], cities$lon[j], 100) %>% \n    filter(END >= 20240000) %>% \n    .[which.min(distance_km), ] %>%\n    pull(STNID)\n})\nweather_data <- get_GSOD(years = 2023, station = cities$stations)\n```\n:::\n\n\n---\n\n\n\n## Hypothesis Tests\n\nFor this, we use the dataset [wheat.txt](https://www.dropbox.com/scl/fi/5g9rh2mzmegss9tvnq2bi/wheat.txt?rlkey=9lyvtr6b9jgv120ijtscdl3mu&st=r95f4h2x&dl=1), which contains wheat prices for the months from March 1982 to March 2012.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(wheat <- read.table(\"wheat.txt\", header=TRUE) %>%\n  na.omit()) %>% {\n\n    ## One-sample t-test\n    t.test(.$Change,\n       alternative = \"greater\",\n       mu = 0,\n       conf.level = 0.95)\n\n    ## Two-sample t-test\n    t.test(Change ~ I(Year > 2000), data = .,      ##  t-test specification \n       alternative = \"greater\",\n       mu = 0,\n       conf.level = 0.95)\n  }\n```\n:::\n\n---\n\n\nOther functions to perform hypothesis tests:\n\n- `var.test()`: Test for equality of variances between two vectors\n- `chisq.test()`: $χ^2$-test for independence\n- Many other packages for specialized tests (`urca`, `lmtest`, `bootUR`)\n\n\n## Task 4.4\n\n- Skim through the paper [\"Incentives Work: Getting Teachers to Come to School\"](http://economics.mit.edu/files/5582) by Duflo et al. Briefly describe the experiment that was conducted.\n\n- Then look at the [data](https://dataverse.harvard.edu/dataset.xhtml?persistentId=hdl:1902.1/VZJXRPURTJ). The datasets `TreatmentSchools` and `Posttest` are sufficient.\n  Load the data into R and examine it. Try to load the Stata dataset (extension: .dta) using the `read_dta` function from the `haven` package.\n\n---\n\n\n- In the `Posttest` dataset, create a variable `treat` that takes the value `TRUE` for students whose School-ID (variable `schid`) appears in the `TreatmentSchools` dataset. Use the `%in%` operator for this. \nExample: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n    a <- 1:10\n    a[1:10 %in% c(2,3)]\n```\n:::\n\n\n\n- Create a subset of the dataset that includes only students who took the written test (`post_writ==1`).\n\n- Compare the mean test scores (variable `post_total_w`) of treatment and non-treatment students.\n\n- Conduct a t-test for the following null hypothesis:\n   \"Treatment and non-treatment students perform equally well on average.\"\n\n\n\n# 5. Flow Control\n\n## General Information\n\nOften, expressions (calculations, estimations, simulations, plots...) should only be executed under certain conditions and/or repeated multiple times. Sometimes an operation is so complex that breaking it down into repeated steps makes it easier to think through and program.\n\nIn such cases, we need constructs:\n\n - Conditional execution (`if`, `else`)\n - Loops (`for`, `while`)\n - Or, as a faster alternative to loops, applying functions to multiple elements simultaneously using different types of `apply()` functions\n - `Vectorize()` modifies functions so they can be applied to multiple elements at once\n\n\n## Conditional Execution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif ( expr ) {\n  ## some code evaluated if is.logical(expr) == TRUE\n} else {\n  ## some other code\n}\n```\n:::\n\n\n\nThe entire construct is still an expression and therefore has a value (specifically, the value of the last evaluated expression):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- if ( 2 > 1 ) {\n  2       ## last evaluated expression\n} else {\n  1\n}   ## result has the value 2\n```\n:::\n\n\n\n---\n\nBe cautious with vector-valued expressions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(5, 3, 2)\ny > 3\n\nif(y > 0) \"Here!\"   ## only evaluates the first entry of y\n```\n:::\n\n\n\nIf you want to check whether all elements of a vector satisfy a certain property, the quantifiers `any()` and `all()` are useful:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif ( all(y > 0) )         ## all() is \"TRUE\" if the argument is a vector of all TRUE values\n{\n    print(\"All y values are greater than 0\")\n}\nelse {\n    print(\"At least one element of y is less than or equal to 0!\")\n}\n```\n:::\n\n\n\n---\n\nOf course, there may be more than two cases to consider, for example:\n\n$$f(x) = \\cases{0 \\text{ for  } x \\leq 5\\\\\n                4 \\text{ for  } 0< x \\leq 5\\\\\n                6 \\text{ otherwise.}}$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstepfunction <- function(x){\n  if ( x <= 0 ) {\n      0\n  } else if (x <= 5 ) {\n      4\n  } else {\n      6\n  }\n}\n```\n:::\n\n\n\n---\n\nAnother option is the `switch(expr, ...)` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## integer expr\nswitch(1, \"first\", \"second\", \"abc\")     ## -> \"first\"\nswitch(2, \"first\", \"second\", \"abc\")     ## -> \"second\"\nswitch(3, \"first\", \"second\", \"abc\")     ## -> \"abc\"\n\n## character expr\nswitch(\"abc\", a = \"first\", b = \"second\", abc = \"mix\")  ## -> \"mix\"\n```\n:::\n\n\n\n---\n\nSometimes we want to check vectorized objects and return a separate value for each entry. For this, we use the `ifelse()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3, NA, 2)\nifelse( is.na(x), \"Missing\", \"Not Missing\")\n\n## absolute value\nx <- c(-3, 5, -8, 2)\nifelse( x < 0, -x, x)\n```\n:::\n\n\n\n\n## Task 5.1\n\nWrite a function `if_test` that takes two objects, `x` and `y`, and checks whether `x` is numeric and `y` is of type character.\nIf both conditions are met, the function should print \"Super\"; otherwise, it should indicate which of the two objects `x`/`y` does not meet the required condition.\n\nTest your function with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif_test(5, \"char\")\n\nif_test(\"abc\", 2)\n\nif_test(list(1,2), matrix(\"a\", 3, 3))\n```\n:::\n\n\nHint: Use `is.character()` and `is.numeric()`.\n\n\n\n## Loops\n\nFrequently, small code blocks need to be executed multiple times. Loops help with this. In R, there are three types of loops:\n\n- `repeat{ Code }`: A loop that executes `Code` indefinitely and must be stopped with `break`.\n\n- `while( Condition) { Code }`: The code `Code` executes as long as `is.logical(Condition)` evaluates to `TRUE`.\n\n- `for (value in values) { Code }`: The code `Code` runs once for each element in the vector `values`. The variable `value` takes on the value of each element during each iteration.\n\nIn addition to `break` (which terminates the loop), there is another control command: `next` (which immediately jumps to the next iteration of the loop).\n\n---\n\n\nExamples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(\"One\",\"Two\",\"Three\")\nfor (v in vec) print(v)\n\nfor (i in 1:10) {\n  print(i + 2)\n}\n```\n:::\n\n\nThe following would yield the same result as the latter for loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\nprint(i + 2)\ni <- 2\nprint(i + 2)\n# ...\ni <- 9\nprint(i + 2)\ni <- 10\nprint(i + 2)\n```\n:::\n\n\n---\n\nExpressions in constructs are evaluated in the environment in which they are called. Thus, the variable `i` has the value 100 after executing the loop:\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:100) {\n  ## some code using the variable i\n}\n```\n:::\n\nAll these constructs can, of course, be freely combined:\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrol <- TRUE\nwhile (control){\n  if (a > b){\n    for (i in seq(along = longObject)){\n      ## do something with i\n    }\n    if (error) break\n  } else {\n    next\n  }\n}\n```\n:::\n\n\n\n\n## Example: Numerical Optimization of a Function\n\nAlgorithmic idea (very naive, thus not suitable for practical use):<br>\nWe want to numerically find the maximum of a downward-opening parabola.\nWe start at a value where we are sure that the parabola is still increasing,\nmove stepwise to the right while checking whether the value of the parabola\nis still increasing significantly. If this is not the case, we stop:\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/parabel-1.png){width=960}\n:::\n:::\n\n\n\n---\n\n\nCode:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparabel <- function(x) -x^2\n\nxx <- -2          ## here we start\nyy <- parabel(xx) ## what is the value of the parabola here?\n\ndY <- 1           ## we initialize a value so that while() does not terminate immediately\nwhile( dY > 0.0000001){\n  xx <- xx + 0.01       ## move xx one step to the right\n  yyNew <- parabel(xx)  ## what is the value of the parabola at the new xx?\n  dY <- yyNew - yy      ## by how much did the value of the parabola increase in this step?\n                        ## this dY is used before the next loop iteration to check\n                        ## whether the condition dY >0.0000001 is still met.\n  yy <- yyNew           ## make yy the new value for the next loop iteration\n}\n```\n:::\n\n\n---\n\n\n\n## Task 5.2\n\n1. Compute the matrix product of A and B without using the `%*%` operator.\n    Use one or more loops and something like <br>`sum(A[1,] * B[,1])` for `C[1,1]`, etc.\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(1:12,4,3)\nB <- matrix(1:9,3,3)\nC <- A %*% B\n```\n:::\n\n    \n\n2. Now create a function `mat_mult` from the loops of the previous subtask,\n   which, when given two matrices, computes their product but first checks with `if`\n   whether the row length of one matrix matches the column length of the other matrix.\n   Test this with the matrices above.\n\n\n\n## Task 5.3\n\n- Write a function `optimizer` that, when given a (real-valued) function, numerically searches for its optimum. Use the example code above.\n\n- Instead of the optimization method used above, try implementing a bisection method.\n  See the Wikipedia article on the [Bisection Method](https://en.wikipedia.org/wiki/Bisection_method).<br>\nHint: To compute the derivative of a function `fun` at a point `x`,\nyou can use the function `numericDeriv()` from the `stats` package as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv.o2 <- new.env()\ndfun <- function(x) {\n    assign(\"x\",x, envir = env.o2)\n    attr(numericDeriv(quote(fun(x)), \"x\", rho = env.o2), which = \"gradient\")[1,1]\n}\n```\n:::\n\n\n\n\n## apply Constructs\n\nLoops in R are relatively slow and can sometimes lead to less readable code. Where possible, loops should be avoided. Often, a loop can be replaced by vectorization (with extreme performance gains since loops are then executed in C rather than in R).\n\nIn addition, R provides a family of `apply` constructs that enable vectorized operations.\n\n---\n\n\nFor working with matrices and arrays, the `apply()` function is available. This function can apply suitable functions to rows or columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(c(2, 6, 3, 4, 5, 7, 8, 4, 1), ncol = 3)\n ## row-wise maximum:\napply(X = A,            ## an array or a matrix\n      MARGIN = 1,       ## Over which indices should the function be applied\n                        ##  (1 -> rows, 2 -> columns)\n      FUN = max         ## which function should be applied?\n)\n\nX <- rnorm(1000) %>%\n  matrix(ncol = 10)\n\napply(X, 2, var)        ## Variances of the columns\n```\n:::\n\n\n\n---\n\nOften, lists are available, and a function needs to be applied to each element, returning a list as a result. The `lapply()` function serves this purpose.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nList <- list(a=c(4,8,7),\n  b=seq(0,100,5),\n  c=c(TRUE,TRUE,FALSE,TRUE)\n)\n\nListSum <- lapply(List, sum)\nclass(ListSum)            ## returns a list\n```\n:::\n\n\n\nOften, the result does not need to be a list but rather a vector (or a matrix/array). This is achieved using `sapply()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nListSum <- sapply(List, sum)\nclass(ListSum)           ## \"numeric\"\n```\n:::\n\n\n\n---\n\nAll members of the apply family accept the `...` argument, allowing additional parameters to be passed to the function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## custom function\nfunnyFun <- function(x, m, std) sum(x)/( 2 * rnorm(1, mean=m, sd=std))\n\n## using `...` to pass 'm' and 'std' to funnyFun:\nsapply(X=List, FUN=funnyFun, m=2, std=5)\n\n## also works for plotting:\npar(mfrow=c(length(List),1))\nlapply(List, plot, main=\"Title\", type=\"l\", lwd=2)\n```\n:::\n\n\n\n\n\n## Task 5.4\n\nCreate a $10\\times 10$ matrix where the $ij$-th element is given by $(i\\cdot j)^{(1/j)}$. Use two nested loops for this. Then, compute the row and column sums of this matrix using an `apply` function of your choice.\n\n\n\n## Additional Useful Language Elements\n\nSometimes, objects need to be created dynamically with names dependent on other variables and later retrieved. This cannot be done using `<-`. Therefore, R provides the functions `assign()` and `get()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobjectName <- \"x\"\n\n## The following assignments are equivalent:\nx <- 2\nassign(\"x\", 2)\nassign(objectName, 2)\n\n## Retrieve the value of object \"x\"\nget(objectName)   ## -> 2\n```\n:::\n\n\n\n---\n\nFurther example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Depending on the value of x, either mean() or sum() is executed\nmyFunc1 <- mean\nmyFunc2 <- sum\n\nx <- 1\nget(paste(\"myFunc\",x,sep=\"\"))(1:10)     ## mean()\nx <- 2\nget(paste(\"myFunc\",x,sep=\"\"))(1:10)     ## sum()\n```\n:::\n\n\n\n---\n\nAnother example demonstrating the usefulness of `assign()`: <br>\nStore the `summary()` output of each variable in the `CPS1985` dataset as `summary_{VariableName}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(CPS1985)\nfor(variable in names(CPS1985))\n{\n    assign(paste(\"summary_\", variable, sep = \"\"), summary(get(variable)))\n    print(paste(\"summary_\", variable, sep = \"\"))\n}\n```\n:::\n\n\n\nWhat exactly is happening here?\n\n---\n\nBreak it down step by step:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Loop iterates over values:\nnames(CPS1985)\n\n## First iteration:\nvariable <- names(CPS1985)[1]\nvariable\nget(variable)\nsummary(get(variable))\npaste(\"summary_\", variable, sep = \"\")\nassign(paste(\"summary_\", variable, sep = \"\"), summary(get(variable)))\n```\n:::\n\n\n\n\n## Error Handling\n\nOften, it is not known in advance whether executing code will result in errors.\n\n- One option: Check all cases that might lead to errors before execution.\n- Another (pragmatic) approach is to use language elements for **error handling**, which are present in many programming languages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalue <- tryCatch({\n  ## some code to be evaluated\n  expr\n}, warning = function(w){\n  ## code evaluated if evaluating expr leads to a warning\n  print(w)\n}, error = function(e){\n  ## code evaluated if evaluating expr leads to an error\n  print(e)\n})\n```\n:::\n\n\n\n\n## Recursion\n\nSometimes quite useful: recursive functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial <- function(n){\n  if (n<0) stop(\"Factorial only for positive integers\")\n\n  if (n<2) return(1)\n\n  n * factorial(n-1)\n}\n```\n:::\n\n\n\n\n## Task 5.5\n\n 1. Replace the loop over the variable with an apply construct.\n 2. How can the use of `assign` and `get` be avoided for this problem?\n\n## Task 5.6\n\nWrite a function named \"fib\" that, given a natural number `n`, computes the `n`-th Fibonacci number. The Fibonacci sequence is defined recursively as follows:\n\n$a_0=0$, $a_1=1$, and $a_n=a_{n-1}+a_{n-2}$.\n\n\n\n\n\n# 6. Regression\n\n## General Information\n\nIn econometrics (which can also be applied to other scientific fields), we often ask questions like:\n - Does income convergence occur (does a low income level lead to higher growth in the future, ceteris paribus)?\n - Is education an important determinant of growth?\n - Does foreign trade accelerate growth?\n - Is political stability important / does violence hinder economic prosperity?\n - Is growth slower in Africa, ceteris paribus?\n\nThe standard tool for such analyses: **multiple linear regression model**\n\n $$y_i = \\beta_0 + \\beta_1 x_{1,i} + \\beta_2 x_{2,i} + \\dots + \\beta_p x_{p,i} + u_i,\\ i=1,\\dots,n$$\nOr, in matrix notation:\n$$\\mathbf{y} = \\mathbf{X}\\beta + \\mathbf{u},$$\nwhere $\\mathbf{y}, \\mathbf{u}\\in\\mathbb{R}^{n}$, $\\mathbf{X}\\in\\mathbb{R}^{n\\times k}$, $\\beta\\in\\mathbb{R}^{k}$, and $k = p + 1$.\n\n\n## Formula Objects\n\nR is designed to easily estimate various statistical models. It provides a specific object class to symbolically describe statistical models, called `formula` objects. See `?formula` for more details.\n\nExample: the regression model\n\n$y_i = \\beta_0 + \\beta_1 x_{1,i} + \\beta_2 x_{2,i} + u_i$\n\ncan be specified in R as a `formula` like this:\n\n`y ~ x1 + x2`\n\n---\n\n\n- Important operators:\n  - `~`: Basis for all models. `y ~ model` specifies that the dependent variable `y` is modeled using the linear predictors described in `model`.\n  - `+`: Models consist of terms separated by `+` (in simple cases, these are variables).\n  - `:`: Creates interaction terms between variables.\n  - `*`: `a*b` is equivalent to `a + b + a:b`.\n  - `^`: `(a + b)^2` is equivalent to `(a + b) * (a + b)`.\n\n- Note: `y ~ x1 + x2^2` is NOT the model $y_i = \\beta_0 + \\beta_1 x_{1,i} + \\beta_2 x^2_{2,i} + u_i$!\n\n- For arithmetic expressions (e.g., variable transformations), use the function `I()`: <br>`y ~ x1 + I(x2^2)`.\n\n- Factor variables in formulas are automatically *dummy coded*.\n\n---\n\nThe standard function for estimating linear models is `lm()`. This function returns an `lm` object with numerous available methods: `summary()`, `plot()`, `predict()`, etc.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(AER)\ndata(GrowthSW)\n\ngrowth.eq1 <- lm(growth ~ rgdp60,\n                 data=GrowthSW)\nsummary(growth.eq1)\n```\n:::\n\n\n\n---\n\nOutput:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = growth ~ rgdp60, data = GrowthSW)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.6309 -1.0485  0.0831  0.8722  5.3183 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 1.796e+00  3.780e-01   4.751 1.21e-05 ***\nrgdp60      4.735e-05  9.494e-05   0.499     0.62    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.908 on 63 degrees of freedom\nMultiple R-squared:  0.003932,\tAdjusted R-squared:  -0.01188 \nF-statistic: 0.2487 on 1 and 63 DF,  p-value: 0.6197\n```\n\n\n:::\n:::\n\n\n---\n\nMultiple variables, transformations:\n\n::: {.cell}\n\n```{.r .cell-code}\ngrowth.eq2 <- lm(growth ~ rgdp60 + tradeshare +\n                 education + I(education^2) + # education linear and squared\n                 revolutions + assassinations, data = GrowthSW)\nsum.eq2 <- summary(growth.eq2)\n```\n:::\n\n\nWithout intercept:\n\n::: {.cell}\n\n```{.r .cell-code}\ngrowth.eq3 <- lm(growth ~ -1 + rgdp60 + tradeshare, data = GrowthSW)\n```\n:::\n\n\nAll variables in the dataset:\n\n::: {.cell}\n\n```{.r .cell-code}\ngrowth.eq4 <- lm(growth ~ ., data = GrowthSW)\n```\n:::\n\n\nExcluding specific variables:\n\n::: {.cell}\n\n```{.r .cell-code}\ngrowth.eq5 <- lm(growth ~ . -rgdp60, data = GrowthSW)\n```\n:::\n\n\n---\n\n\nWith factor variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGrowthSW <- GrowthSW %>%\n  tibble::rownames_to_column(\"country\") %>%\n  mutate(continent = factor(ifelse(\n    country %in% c(\"Zaire\",\"Niger\",\"Senegal\", \"Zimbabwe\" ,\"Togo\",\n           \"South Africa\", \"Sierra Leone\" ,\"Ghana\",\"Kenya\",\n           \"Mauritius\"), \"africa\", \"other\"), levels = c(\"africa\", \"other\")))\n\ngrowth.eq6 <- lm(growth ~ rgdp60 + tradeshare + continent, data = GrowthSW)\nsummary(growth.eq6)\n```\n:::\n\n\n\nInteraction terms:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrowth.eq7 <- lm(growth ~\n                     log(rgdp60) * continent +\n                     tradeshare+log(education)+\n                     revolutions+assassinations,\n                 data=GrowthSW)\nsum.eq7 <- summary(growth.eq7)\n```\n:::\n\n\n\n\n\n## Accessing Regression Results\n\n- Use functions such as `coefficients()`, `fitted()`, `residuals()`.\n- Or directly access the `lm` or `summary.lm` list objects:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(growth.eq7)    ## structure of lm object\nstr(sum.eq7)       ## structure of summary.lm object\n\n# elements in lm object\ngrowth.eq7$coefficients\ngrowth.eq7$residuals\ngrowth.eq7$fitted\n\n# summary.lm provides additional information:\nsum.eq7$coefficients      ## matrix with estimates, std-dev, t-stat, p-value\nsum.eq7$sigma             ## residual standard error estimate\nsum.eq7$adj.r.squared     ## adjusted R^2 of regression\n```\n:::\n\n\n\n\n\n## Model Selection\n\nTo determine which model is \"better,\" model selection criteria like AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion) are commonly used. The model with the lowest value is considered the \"best.\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Akaike Criterion\nAIC(growth.eq5)     # smaller is better\nAIC(growth.eq1)\n\n# Bayesian Information Criterion\nBIC(growth.eq5)     # smaller is better\nBIC(growth.eq1)\n```\n:::\n\n\n\n---\n\nThe `MASS` package provides the `stepAIC` function, which iteratively finds an \"optimal\" model starting from a large model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"MASS\")\nlibrary(MASS)\n?stepAIC\ngrowth.eqAIC <- stepAIC(lm(growth ~ (log(rgdp60) + tradeshare + log(education)+\n                                      revolutions + assassinations + continent)^2,\n                            data=GrowthSW))\n```\n:::\n\n\n\n\n## Task 6.1\nUse the Growth dataset from above.\n\n 1. Test a few possibilities for formula input:\n   \n    - With and without a constant\n    - Quadratic, cubic, or duplicated regressors\n    - Interactions (of groups)\n    - Use the `stepAIC()` function\n  \n 2. Select one of your models and apply the `summary()` method to it. Discuss the estimates, standard errors, p-values, residual sum of squares, and the adjusted $R^2$ value.\n\n\n## Model Diagnosis and Tests\n### 1. Heteroskedasticity\nGraphical examination:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuhat_AIC <- resid(growth.eqAIC) # growth.eqAIC$residuals\nyhat_AIC <- fitted(growth.eqAIC)\nplot(yhat_AIC,uhat_AIC^2, main=\"Squared Residuals vs. Fitted Values\")\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/step_aic-1.png){width=960}\n:::\n:::\n\n\n\n---\n\nHeteroskedasticity tests (Breusch-Pagan, White):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Breusch - Pagan\nbptest(growth.eqAIC)\n\n# White Test\nsummary(lm(I(uhat_AIC^2)~ yhat_AIC + I(yhat_AIC^2))\n        )$r.squared * length(yhat_AIC) %>%\n  pchisq(df = 2, lower.tail = FALSE)\n```\n:::\n\n\n\nSolution: Heteroskedasticity-robust variance-covariance matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvcov.robust <- vcovHC(growth.eqAIC, type = \"HC\")\ncoeftest(growth.eqAIC,vcov=vcov.robust)\n```\n:::\n\n\n\n---\n\n### Model Diagnosis: 2. Nonlinearity\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(yhat_AIC,uhat_AIC,main=\"Residuals vs. Fitted Values\")\n```\n\n::: {.cell-output-display}\n![](PIR_quardo_files/figure-revealjs/lm_nonlinear-1.png){width=960}\n:::\n:::\n\n\n\n---\n\nRESET Test:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresettest(growth.eqAIC)\n```\n:::\n\n\n\nAdditional diagnostic plots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(growth.eqAIC)\n```\n:::\n\n\n\n---\n\n### Hypothesis Testing\n\n- Decisions on simple hypotheses of the form $H_0: \\beta_j = 0$ can be directly read from the output\n- Similarly: Overall F-test\n- Further hypotheses (e.g., $H_0: \\beta_j = 3$) or composite hypotheses can be tested using the `linearHypothesis()` function from the `car` package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Symbolic notation:\nlinearHypothesis(growth.eqAIC, \"log(education)=2\")\n\n## Alternative form of hypothesis: R %*% beta = r  (where R is a 1xk vector, r is scalar)\nR <- c(0,0,0,1,0,0,0,0,0)   # 4th entry selects the 4th coefficient\nr <- 2                      # .. which should be 2 according to H_0\nlinearHypothesis( growth.eqAIC , hypothesis.matrix =R, rhs=r )\n\n## Heteroskedasticity-robust test:\nlinearHypothesis(growth.eqAIC,\"log(education)=2\",vcov=vcov.robust)\n```\n:::\n\n\n\n---\n\n### Multiple Hypothesis Testing (F-Tests)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Symbolic notation\nlinearHypothesis(growth.eqAIC,\n                 c(\"log(rgdp60)=0\",\"log(rgdp60):assassinations=0\"))\n\n## Using the formulation R %*% beta = r:\nR <- matrix(c(0,1,rep(0,7), rep(0,7),1,0),nrow=2, byrow=TRUE)\nr <- c(0,0)\nlinearHypothesis(growth.eqAIC,R,r)\n```\n:::\n\n\n\n### Confidence Intervals\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfint(growth.eqAIC,parm=c(\"revolutions\"),level=0.9)\n```\n:::\n\n\n\n\n## Prediction\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## New observations\nX0 <- data.frame( growth=c(NA,NA),\n                  revolutions=c(0.3,0.13),\n                  rgdp60=c(2000,6000),\n                  tradeshare=c(0.3,0.7),\n                  continent=factor(c(\"africa\",\"other\"),\n                                   levels=c(\"other\",\"africa\")),\n                  assassinations=c(0.4,0.2),\n                  education=c(2,4)  )\n\nrownames(X0) <- c(\"Country 1\", \"Country 2\")\n\n## Point prediction, prediction interval, etc.\npredict(growth.eqAIC, newdata=X0, se.fit=TRUE, interval=\"prediction\")\n```\n:::\n\n\n\n\n\n## Task 6.2\n\n- Use the `CPS1985` dataset to specify and estimate an ad-hoc regression model for the logarithm of hourly wages.\n- Starting from a very general model, perform model selection by iteratively removing the least significant regressor. Then, test the exclusion restrictions applied in the process.<br>\n  **Hints:**\n   - General model: Use a squared formula for all possible interactions.\n   - Implement a loop that checks whether the maximum p-value is greater than 5%.\n   - Remove the respective regressor from the model. Important: To simplify the removal of individual regressors, ensure that the model outputs matrix X using `lm(y~x, x=TRUE)`. The design matrix `X` can then be accessed via `a$x` when `a <- lm(y~x, x=TRUE)`.\n\n---\n\n- Compare the two models using appropriate diagnostic tests, criteria, and graphical representations. Decide on the better model.\n- Estimate the expected wage for an employee whose explanatory characteristics correspond to the median values. Also, determine the expected wage for an \"average worker.\"<br>\n  **Hint:** Use a model that includes only numerical explanatory variables.\n- Provide a prediction interval for both cases.\n  \n\n\n## Some Rules for Efficient Code\n\n- **Vectorize!** This ensures that loops are executed in C rather than in R.\n\n- **Do not dynamically increase object size in loops**; instead, initialize an empty object first and then populate it.\n\n- Some R functions have significant *overhead* to handle various cases. Often, there are more specific, faster alternatives, such as:\n  - `lm()` vs. `lm.fit()` or `.lm.fit()`\n\n- Use **profiling methods** to identify where execution time is high and where optimization may be worthwhile.\n\n- If necessary, implement **bottlenecks in C/C++ or Fortran**.\n\n- Balance **faster execution time vs. extra implementation time** for optimizations.\n\n\n# Thanks!\nSlides created via  [**Quarto**](https://quarto.org), a multi-language version of R Markdown that uses knitr to execute Rmd files.\n\nThe chakra comes from [remark.js](https://remarkjs.com), [**knitr**](http://yihui.name/knitr), and [R Markdown](https://rmarkdown.rstudio.com).\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "PIR_quardo_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}