{
  "hash": "b8a21bc47cfc604dfaf79a846ffbd226",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to R\"\nsubtitle: \"Session 2 - Objects\"\nauthor: \"\"\nfilters:\n  - diagram\ndiagram:\n  engine:\n    tikz:\n      header-includes:\n        - '\\usepackage{adjustbox,xcolor}'\n        - '\\usetikzlibrary{arrows, shapes}'\n        - '\\definecolor{UMdblue}{RGB}{0,28,61}'\n        - '\\definecolor{UMlblue}{RGB}{0,162,219}'\n        - '\\definecolor{UMorangered}{RGB}{232,78,16}'\n        - '\\definecolor{UMorange}{RGB}{243,148,37}'\n        - '\\definecolor{UMred}{RGB}{174,11,18}'\n---\n\n\n# Session Overview\n\n1.  [Objects](#objects)\n2.\t[Vectors](#vectors)\n3.  [Matrices](#matrices)\n4.\t[lists](#lists)\n5.\t[Data frames](#datframes)\n\n# Objects {#objects}\n\n## Objects\n- In R, **everything is an object**.\n- Objects have a name that is assigned with `<-` (recommended) or `=`.\n- Names have to start with a letter and include only letters,   numbers, and characters such as “.” and “_”.\n- R is  **case sensitive:** $\\Rightarrow Name\\neq name$!\n\n- Objects can store vectors, matrices, lists, data frames, functions...\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate object x (no output):\nx <- 5\n# display log(x)\nlog(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.609438\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# object X is not defined => error message \nX\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'X' not found\n```\n\n\n:::\n:::\n\n\n# Vectors {#vectors}\n\n- Vectors can store multiple types of information (e.g., numbers or \"characters\").\n- To define a 3-dimensional vector named \"vec\", use `vec<- c(value1,value2,value3)`.\n- Operators and functions can be applied to vectors, which means they are applied to **each of the elements individually**.\n\n::: {.cell}\n\n```{.r .cell-code}\n# define vector named 'vec'\nvec<-c(1,2,3)\n# take the square root of 'vec' and store the result in 'sqrt_vec'\nsqrt_vec=sqrt(vec)\n# display sqrt_vec\nprint(sqrt_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000000 1.414214 1.732051\n```\n\n\n:::\n:::\n\n\n## Vectors - some helpful shortcuts\n- R has built-in functions that generate sequences (useful for loops or plots, among other things). \n- We can also repeat elements using `rep()`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate sequence 5,6,...,10\n5:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# generate sequence from 1 to 10 in steps of 0.5\nseq(from=1,to=5,by=0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n```\n\n\n:::\n\n```{.r .cell-code}\n#generate 4-dimensional vector of ones\nrep(1,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 1 1\n```\n\n\n:::\n:::\n\n## Order matters!\n- **Be aware of the order of operations!**\n- compare the following:\n\n::: {.cell}\n\n```{.r .cell-code}\n1+2:3^2 # '^2' evaluated before ':', only then '+1' is evaluated\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n1+2:3*4 # first ':', then '*4', then '+1'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  9 13\n```\n\n\n:::\n\n```{.r .cell-code}\n# use brackets to avoid confusion or mistakes\n(1+2):(3*4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  3  4  5  6  7  8  9 10 11 12\n```\n\n\n:::\n:::\n\n## Summarizing vectors\n- R has built-in functions to summarize the information stored in vectors.\n- Remark: R is very good at generating random numbers!\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example: generate 100 random draws from a normal distribution with mean 1\n# and standard deviation 2\nnorm.vec=rnorm(n=100,mean=1,sd=2)\n# get mean \nmean(norm.vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9691971\n```\n\n\n:::\n\n```{.r .cell-code}\n# get standard deviation \nsd(norm.vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.199763\n```\n\n\n:::\n\n```{.r .cell-code}\n# get maximum\nmax(norm.vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.278101\n```\n\n\n:::\n:::\n\n\n## logical operators\n\n- logical operators can be either `TRUE` or `FALSE`.\n- Extremely useful for conditional statements, e.g. `if(condition is TRUE){do this}else{do that}`.\n- We can check if two objects are equal by `==`, different by `!=` or compare them with `<` and `>`.\n- We can combine logical statements with \"AND\" `&` and \"OR\" `|`\n\n::: {.cell}\n\n```{.r .cell-code}\n# define  objects \nobj1<-1\nobj2<-2\nobj3<-1 # same value as obj1\nobj1==obj2 # false statement\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nobj1!=obj2 # true statement\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nobj1==obj2 & obj1==obj3 # FALSE AND TRUE => FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nobj1==obj2 | obj1==obj3 # FALSE OR TRUE => TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n---\n\n- We can also use logical operators in vectors.\n- the AND and OR operators `&` and `|` are then applied element-wise.\n\n::: {.cell}\n\n```{.r .cell-code}\nvec2=1:5 # defines vector vec2=(1,2,3,4,5)\nvec2==3  # =FALSE if element is not 3, =TRUE if element is 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nvec2>=2&vec2<5 # Only TRUE for elements >=2 and <5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nvec2>=2|vec2<5 # TRUE for all elements since either >=2 or <5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE TRUE TRUE TRUE\n```\n\n\n:::\n:::\n\n\n## Characters \n- Vectors can also store characters.\n- characters are enclosed in `\"\"`or `''`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# define a vector of 2 cities\ncities<-c('Maastricht', \"Amsterdam\",'Rotterdam')\nprint(cities)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Maastricht\" \"Amsterdam\"  \"Rotterdam\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# combine characters and numbers => numbers turn into characters\nmix=c(1,\"2\")\nprint(mix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# now that numbers are converted to characters, numerical operations\n# produce an error\nmix+1\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in mix + 1: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n## Names\n- You can give the elements of your vector names either directly or using the `names()` command.\n- This is very useful for accessing elements (see nect slide)\n\n::: {.cell}\n\n```{.r .cell-code}\navg_temp<-c(Maastricht=14.2, Amsterdam=13.4,Rotterdam=13.7)\nprint(avg_temp) # names appear on top of elements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMaastricht  Amsterdam  Rotterdam \n      14.2       13.4       13.7 \n```\n\n\n:::\n\n```{.r .cell-code}\nnames(avg_temp) # returns names of elements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Maastricht\" \"Amsterdam\"  \"Rotterdam\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# Alternatively, we can define data and names separately\ntemp<-c(14.2,13.4,13.7)\nnames(temp)<-cities # recall that we have defined \"cities\" earlier!\nprint(temp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMaastricht  Amsterdam  Rotterdam \n      14.2       13.4       13.7 \n```\n\n\n:::\n:::\n\n## Accessing elements\n- One can access the elements of a vector either by name or position.\n\n::: {.cell}\n\n```{.r .cell-code}\n# return the second element of \"avg_temp\" defined before\navg_temp[2] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAmsterdam \n     13.4 \n```\n\n\n:::\n\n```{.r .cell-code}\n# return the element corresponding to \"Maastricht\"\navg_temp[\"Maastricht\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMaastricht \n      14.2 \n```\n\n\n:::\n\n```{.r .cell-code}\n# trying to access a non-existing element yields \"NA\"\n# ( for \"not available\"), i.e. a missing value\navg_temp[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<NA> \n  NA \n```\n\n\n:::\n:::\n\n\n---\n\n\n- We can also add elements to an existing vector.\n\n::: {.cell}\n\n```{.r .cell-code}\n# now add another city to avg_temp\navg_temp[\"Tilburg\" ]<- 14.7\n# now the fourth element is defined!\navg_temp[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTilburg \n   14.7 \n```\n\n\n:::\n:::\n\n\n## More on NA, NaN, Inf\n- `NA` (\"not available\") indicates missing values. \n- Anything combined with `NA` yields `NA`.\n- `NaN`(\"not a number\") indicates the result of a mathematically  undefined operation.\n\n::: {.cell}\n\n```{.r .cell-code}\n#define another vector\nvec3=c(-1.2,NA,0)\n# combine avg_temp and vec3\nvec4=c(avg_temp,vec3) \n# divide elements by 0; notice the different outcomes\nvec4/0 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMaastricht  Amsterdam  Rotterdam    Tilburg                                  \n       Inf        Inf        Inf        Inf       -Inf         NA        NaN \n```\n\n\n:::\n:::\n\n\n# Matrices {#matrices}\n- We can create a matrix with `m` rows directly using `matrix(vector,nrow=m)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create matrix with 3 rows; fill numbers by row\nmat1<-matrix(1:12,nrow=3,byrow=TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n```\n\n\n:::\n:::\n\n\n---\n\n- We can also combine vectors of the same length by row with `rbind(v1,v2,...)` or by column by `cbind(v1,v2,...)`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# create vectors v1, v2 and v3 and combine them for same result\nv1<-1:4\nv2<-5:8\nv3<-9:12\nmat2=rbind(v1,v2,v3)\nmat2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   [,1] [,2] [,3] [,4]\nv1    1    2    3    4\nv2    5    6    7    8\nv3    9   10   11   12\n```\n\n\n:::\n:::\n\n\n\n# Matrix indexing\n- We can give the rows and columns names using `rownames()` and `colnames()`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# assign names to columns\ncolnames(mat1)<-c(\"col1\",\"col2\",\"col3\",\"col4\")\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     col1 col2 col3 col4\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n```\n\n\n:::\n\n```{.r .cell-code}\n# assign names to rows\nrownames(mat1)<-c(\"row1\",\"row2\",\"row3\")\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     col1 col2 col3 col4\nrow1    1    2    3    4\nrow2    5    6    7    8\nrow3    9   10   11   12\n```\n\n\n:::\n:::\n\n## Accessing elements\n\n- We can access single elements by `[rownumber,colnumber]`, the `k`-th row by `[k,]` and the `k`-th column by `[,k]`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# get element in second row in third column\nmat1[2,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\n# get second row\nmat1[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncol1 col2 col3 col4 \n   5    6    7    8 \n```\n\n\n:::\n\n```{.r .cell-code}\n# get third column\nmat1[,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nrow1 row2 row3 \n   3    7   11 \n```\n\n\n:::\n:::\n\n\n---\n\n- If rows/columns have names, we can also use those.\n- Using vectors, we can also create more complicated subsets of matrices.\n\n::: {.cell}\n\n```{.r .cell-code}\n# get sub-matrix using vectors\nmat1[c(2,3),c(1:3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     col1 col2 col3\nrow2    5    6    7\nrow3    9   10   11\n```\n\n\n:::\n\n```{.r .cell-code}\n# get second row using names (recall definition of mat2)\nmat2[\"v2\",]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 6 7 8\n```\n\n\n:::\n:::\n\n\n## Exercise\n1. Create the 3x3 identity matrix \"by hand\". To do so:\n\ta) create 3 vectors of with zeros and ones in the appropriate spots.\n\tb) use `rbind()` or `cbind()` to combine them into the identity matrix.\n\tc) store the identity matrix as the object \"I_mat\".\n\td) R makes your life easy: type `diag(3)` in your console.\n\n2. Replicate the following Excel-matrix:\n\n![](figures/excel-screenshot.png){width=50%}\n\t\n# Matrix algebra\n- R can do matrix \"regular\" algebra, and even lets you do operations that are not well-defined mathematically. \n\n- `t(A)`is the transpose of the matrix `A`.\n\n::: {.cell}\n\n```{.r .cell-code}\n# define matrix containing normal data\ndata.vec=rnorm(9,mean=0,sd=1)\nA=matrix(data.vec,nrow=3) \nA # return A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]       [,3]\n[1,]  1.6875871  0.3722665 -1.8336565\n[2,] -0.2810924 -0.6926725  1.2965952\n[3,]  2.2448227  1.1024333 -0.8741331\n```\n\n\n:::\n\n```{.r .cell-code}\nt(A) # return the transpose\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]       [,3]\n[1,]  1.6875871 -0.2810924  2.2448227\n[2,]  0.3722665 -0.6926725  1.1024333\n[3,] -1.8336565  1.2965952 -0.8741331\n```\n\n\n:::\n:::\n\n\n---\n\n- `solve(A)` returns the inverse of an invertible matrix.\n\n::: {.cell}\n\n```{.r .cell-code}\nsolve(A) # return the inverse of A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]      [,3]\n[1,]  0.3072776  0.6325424 0.2936736\n[2,] -0.9938667 -0.9849697 0.6238217\n[3,] -0.4643321  0.3821867 0.3969269\n```\n\n\n:::\n:::\n\n\n---\n\n- `*`does element-wise multiplication.\n- `%*%` does matrix multiplication .\n\n::: {.cell}\n\n```{.r .cell-code}\n# element-wise multiplication\nA*solve(A) # NOT the identity matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]      [,2]       [,3]\n[1,]  0.5185577 0.2354743 -0.5384965\n[2,]  0.2793684 0.6822614  0.8088443\n[3,] -1.0423432 0.4213353 -0.3469670\n```\n\n\n:::\n\n```{.r .cell-code}\n# matrix multiplication\nA%*%solve(A) # yields the identity (up to a small error due to the\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              [,1]         [,2] [,3]\n[1,]  1.000000e+00 2.220446e-16    0\n[2,] -1.110223e-16 1.000000e+00    0\n[3,]  5.551115e-17 2.775558e-16    1\n```\n\n\n:::\n\n```{.r .cell-code}\n# numerical computation of the inverse)\n```\n:::\n\n\n\n## Lists\n- A `list` is a generic collection of objects.\n- Unlike vectors, the components can have different types (e.g., numeric and character).\n",
    "supporting": [
      "IntroductionR_Session2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}